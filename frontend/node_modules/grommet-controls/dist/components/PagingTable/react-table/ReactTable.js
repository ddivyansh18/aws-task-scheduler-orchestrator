/* eslint-disable no-nested-ternary,no-shadow,no-param-reassign,
prefer-destructuring,no-mixed-operators */
import React, { Component } from 'react';
import _ from './utils';
import defaultProps from './defaultProps';
import { focusNextElement, focusPrevElement } from '../DOM';
export default class ReactTable extends Component {
    constructor(props) {
        super(props);
        this.rowRef = [];
        this.footerRef = null;
        this.filterRef = null;
        this.headerRef = null;
        this.headerGroupsRef = null;
        this.getResolvedState = (props, state) => (Object.assign(Object.assign(Object.assign(Object.assign({}, _.compactObject(this.state)), _.compactObject(this.props)), _.compactObject(state)), _.compactObject(props)));
        this.fireFetchData = () => {
            this.props.onFetchData(this.getResolvedState(), this);
        };
        this.getStateOrProp = key => _.getFirstDefined(this.state[key], this.props[key]);
        this.getMinRows = () => _.getFirstDefined(this.props.minRows, this.getStateOrProp('pageSize'));
        // User actions
        this.onPageChange = page => {
            const { onPageChange, collapseOnPageChange } = this.props;
            const newState = { page };
            if (collapseOnPageChange) {
                newState.expanded = {};
            }
            this.setStateWithData(newState, this.state, this.props, () => onPageChange && onPageChange(page));
        };
        this.onPageSizeChange = newPageSize => {
            const { onPageSizeChange } = this.props;
            const { pageSize, page } = this.getResolvedState();
            // Normalize the page to display
            const currentRow = pageSize * page;
            const newPage = Math.floor(currentRow / newPageSize);
            this.setStateWithData({
                pageSize: newPageSize,
                page: newPage,
            }, this.state, this.props, () => onPageSizeChange && onPageSizeChange(newPageSize, newPage));
        };
        this.sortColumn = (column, additive) => {
            const { sorted, skipNextSort, defaultSortDesc } = this.getResolvedState();
            const firstSortDirection = Object.prototype.hasOwnProperty.call(column, 'defaultSortDesc')
                ? column.defaultSortDesc
                : defaultSortDesc;
            const secondSortDirection = !firstSortDirection;
            // we can't stop event propagation from the column resize move handlers
            // attached to the document because of react's synthetic events
            // so we have to prevent the sort function from actually sorting
            // if we click on the column resize element within a header.
            if (skipNextSort) {
                this.setStateWithData({
                    skipNextSort: false,
                }, this.state, this.props);
                return;
            }
            const { onSortedChange } = this.props;
            let newSorted = _.clone(sorted || []).map(d => {
                d.desc = _.isSortingDesc(d);
                return d;
            });
            if (!_.isArray(column)) {
                // Single-Sort
                const existingIndex = newSorted.findIndex(d => d.id === column.id);
                if (existingIndex > -1) {
                    const existing = newSorted[existingIndex];
                    if (existing.desc === secondSortDirection) {
                        if (additive) {
                            newSorted.splice(existingIndex, 1);
                        }
                        else {
                            existing.desc = firstSortDirection;
                            newSorted = [existing];
                        }
                    }
                    else {
                        existing.desc = secondSortDirection;
                        if (!additive) {
                            newSorted = [existing];
                        }
                    }
                }
                else if (additive) {
                    newSorted.push({
                        id: column.id,
                        desc: firstSortDirection,
                    });
                }
                else {
                    newSorted = [
                        {
                            id: column.id,
                            desc: firstSortDirection,
                        },
                    ];
                }
            }
            else {
                // Multi-Sort
                const existingIndex = newSorted.findIndex(d => d.id === column[0].id);
                // Existing Sorted Column
                if (existingIndex > -1) {
                    const existing = newSorted[existingIndex];
                    if (existing.desc === secondSortDirection) {
                        if (additive) {
                            newSorted.splice(existingIndex, column.length);
                        }
                        else {
                            column.forEach((_d, i) => {
                                newSorted[existingIndex + i].desc = firstSortDirection;
                            });
                        }
                    }
                    else {
                        column.forEach((_d, i) => {
                            newSorted[existingIndex + i].desc = secondSortDirection;
                        });
                    }
                    if (!additive) {
                        newSorted = newSorted.slice(existingIndex, column.length);
                    }
                    // New Sort Column
                }
                else if (additive) {
                    newSorted = newSorted.concat(column.map(d => ({
                        id: d.id,
                        desc: firstSortDirection,
                    })));
                }
                else {
                    newSorted = column.map(d => ({
                        id: d.id,
                        desc: firstSortDirection,
                    }));
                }
            }
            this.setStateWithData({
                page: (!sorted.length && newSorted.length) || !additive
                    ? 0
                    : this.state.page,
                sorted: newSorted,
            }, this.state, this.props, () => onSortedChange && onSortedChange(newSorted, column, additive));
        };
        this.filterColumn = (column, value) => {
            const { filtered } = this.getResolvedState();
            const { onFilteredChange } = this.props;
            // Remove old filter first if it exists
            const newFiltering = (filtered || []).filter(x => x.id !== column.id);
            if (value !== '') {
                newFiltering.push({
                    id: column.id,
                    value,
                });
            }
            this.setStateWithData({
                filtered: newFiltering,
            }, this.state, this.props, () => onFilteredChange && onFilteredChange(newFiltering, column, value));
        };
        this.resizeColumnStart = (event, column, isTouch) => {
            event.stopPropagation();
            const parentWidth = event.target.parentElement.getBoundingClientRect()
                .width;
            let pageX;
            if (isTouch) {
                pageX = event.changedTouches[0].pageX;
            }
            else {
                pageX = event.pageX;
            }
            this.setStateWithData({
                currentlyResizing: {
                    id: column.id,
                    startX: pageX,
                    parentWidth,
                },
            }, this.state, this.props, () => {
                if (isTouch) {
                    document.addEventListener('touchmove', this.resizeColumnMoving);
                    document.addEventListener('touchcancel', this.resizeColumnEnd);
                    document.addEventListener('touchend', this.resizeColumnEnd);
                }
                else {
                    document.addEventListener('mousemove', this.resizeColumnMoving);
                    document.addEventListener('mouseup', this.resizeColumnEnd);
                    document.addEventListener('mouseleave', this.resizeColumnEnd);
                }
            });
        };
        this.resizeColumnMoving = event => {
            event.stopPropagation();
            const { onResizedChange } = this.props;
            const { resized, currentlyResizing } = this.getResolvedState();
            // Delete old value
            const newResized = resized.filter(x => x.id !== currentlyResizing.id);
            let pageX;
            if (event.type === 'touchmove') {
                pageX = event.changedTouches[0].pageX;
            }
            else if (event.type === 'mousemove') {
                pageX = event.pageX;
            }
            // Set the min size to 10 to account for margin and border or else the
            // group headers don't line up correctly
            const newWidth = Math.max(currentlyResizing.parentWidth + pageX - currentlyResizing.startX, 11);
            newResized.push({
                id: currentlyResizing.id,
                value: newWidth,
            });
            this.setStateWithData({
                resized: newResized,
            }, this.state, this.props, () => onResizedChange && onResizedChange(newResized, event));
        };
        this.resizeColumnEnd = event => {
            event.stopPropagation();
            const isTouch = event.type === 'touchend' || event.type === 'touchcancel';
            if (isTouch) {
                document.removeEventListener('touchmove', this.resizeColumnMoving);
                document.removeEventListener('touchcancel', this.resizeColumnEnd);
                document.removeEventListener('touchend', this.resizeColumnEnd);
            }
            // If its a touch event clear the mouse one's as well because sometimes
            // the mouseDown event gets called as well, but the mouseUp event doesn't
            document.removeEventListener('mousemove', this.resizeColumnMoving);
            document.removeEventListener('mouseup', this.resizeColumnEnd);
            document.removeEventListener('mouseleave', this.resizeColumnEnd);
            // The touch events don't propagate up to the sorting's onMouseDown event so
            // no need to prevent it from happening or else the first click after a touch
            // event resize will not sort the column.
            if (!isTouch) {
                this.setStateWithData({
                    skipNextSort: true,
                    currentlyResizing: undefined,
                }, this.state, this.props);
            }
        };
        this.rowRef = [];
        this.state = {
            page: 0,
            pageSize: props.defaultPageSize,
            sorted: props.defaultSorted,
            expanded: props.defaultExpanded,
            filtered: props.defaultFiltered,
            resized: props.defaultResized,
            currentlyResizing: undefined,
            skipNextSort: false,
        };
    }
    componentDidMount() {
        this.fireFetchData();
    }
    static getDerivedStateFromProps(nextProps, oldState) {
        const newState = Object.assign(Object.assign({}, oldState), nextProps);
        // Do a deep compare of new and old `defaultOption` and
        // if they are different reset `option = defaultOption`
        const defaultableOptions = ['sorted', 'filtered', 'resized', 'expanded'];
        defaultableOptions.forEach(x => {
            const defaultName = `default${x.charAt(0).toUpperCase() + x.slice(1)}`;
            if (JSON.stringify(oldState[defaultName]) !==
                JSON.stringify(newState[defaultName])) {
                newState[x] = newState[defaultName];
            }
        });
        // If they change these table options, we need to reset defaults
        // or else we could get into a state where the user has changed the UI
        // and then disabled the ability to change it back.
        // e.g. If `filterable` has changed, set `filtered = defaultFiltered`
        const resettableOptions = ['sortable', 'filterable', 'resizable'];
        resettableOptions.forEach(x => {
            if (oldState[x] !== newState[x]) {
                const baseName = x.replace('able', '');
                const optionName = `${baseName}ed`;
                const defaultName = `default${optionName.charAt(0).toUpperCase() +
                    optionName.slice(1)}`;
                newState[optionName] = newState[defaultName];
            }
        });
        // Props that trigger a data update
        if (oldState.data !== newState.data ||
            JSON.stringify(oldState.columns) !== JSON.stringify(newState.columns) ||
            oldState.pivotBy !== newState.pivotBy ||
            oldState.sorted !== newState.sorted ||
            oldState.filtered !== newState.filtered) {
            return ReactTable.getStateWithData(ReactTable.getDataModel(newState, nextProps), oldState, nextProps);
        }
        return null;
    }
    static getStateWithData(newState, oldState, props) {
        const newResolvedState = Object.assign(Object.assign(Object.assign({}, oldState), newState), props);
        const { freezeWhenExpanded } = newResolvedState;
        // Default to unfrozen state
        newResolvedState.frozen = false;
        // If freezeWhenExpanded is set, check for frozen conditions
        if (freezeWhenExpanded) {
            // if any rows are expanded, freeze the existing data and sorting
            const keys = Object.keys(newResolvedState.expanded);
            for (let i = 0; i < keys.length; i += 1) {
                if (newResolvedState.expanded[keys[i]]) {
                    newResolvedState.frozen = true;
                    break;
                }
            }
        }
        // If the data isn't frozen and either the data or
        // sorting model has changed, update the data
        if ((oldState.frozen && !newResolvedState.frozen) ||
            oldState.sorted !== newResolvedState.sorted ||
            oldState.filtered !== newResolvedState.filtered ||
            oldState.showFilters !== newResolvedState.showFilters ||
            (!newResolvedState.frozen &&
                oldState.resolvedData !== newResolvedState.resolvedData)) {
            // Handle collapseOnsortedChange & collapseOnDataChange
            if ((oldState.sorted !== newResolvedState.sorted &&
                props.collapseOnSortingChange) ||
                oldState.filtered !== newResolvedState.filtered ||
                oldState.showFilters !== newResolvedState.showFilters ||
                (oldState.sortedData &&
                    !newResolvedState.frozen &&
                    oldState.resolvedData !== newResolvedState.resolvedData &&
                    props.collapseOnDataChange)) {
                newResolvedState.expanded = {};
            }
            Object.assign(newResolvedState, ReactTable.getSortedData(newResolvedState, props));
        }
        // Set page to 0 if filters change
        if (oldState.filtered !== newResolvedState.filtered) {
            newResolvedState.page = 0;
        }
        // Calculate pageSize all the time
        if (newResolvedState.sortedData) {
            newResolvedState.pages = newResolvedState.manual
                ? newResolvedState.pages
                : Math.ceil(newResolvedState.sortedData.length / newResolvedState.pageSize);
            newResolvedState.page = Math.max(newResolvedState.page >= newResolvedState.pages
                ? newResolvedState.pages - 1
                : newResolvedState.page, 0);
        }
        return newResolvedState;
    }
    setStateWithData(newState, oldState, props, cb) {
        const newResolvedState = ReactTable.getStateWithData(newState, oldState, props);
        return this.setState(newResolvedState, () => {
            if (cb) {
                cb();
            }
            if (oldState.page !== newResolvedState.page ||
                oldState.pageSize !== newResolvedState.pageSize ||
                oldState.sorted !== newResolvedState.sorted ||
                oldState.filtered !== newResolvedState.filtered) {
                this.fireFetchData();
            }
        });
    }
    render() {
        const resolvedState = this.getResolvedState();
        const { getProps, getTableProps, getTheadGroupProps, getTheadGroupTrProps, getTheadProps, getTheadTrProps, getTheadThProps, getTheadFilterProps, getTheadFilterTrProps, getTheadFilterThProps, getFilterInputProps, getTbodyProps, getTrGroupProps, getTrProps, getTdProps, getExpanderProps, getTfootProps, getTfootTrProps, getTfootTdProps, getPaginationProps, getLoadingProps, getNoDataProps, getResizerProps, showPagination, showPaginationTop, showPaginationBottom, manual, loadingText, noDataText, sortable, multiSort, resizable, filterable, 
        // Pivoting State
        pivotIDKey, pivotValKey, pivotBy, subRowsKey, aggregatedKey, originalKey, indexKey, groupedByPivotKey, expanderTdDefaultProps, 
        // State
        loading, pageSize, page, sorted, filtered, resized, expanded, pages, onExpandedChange, 
        // Components
        TableComponent, TheadComponent, TbodyComponent, TrGroupComponent, TrComponent, ThComponent, TdComponent, CellTextComponent, TfootComponent, PaginationComponent, LoadingComponent, SubComponent, NoDataComponent, ResizerComponent, ExpanderComponent, PivotValueComponent, PivotComponent, AggregatedComponent, FilterComponent, PadRowComponent, 
        // Data model
        resolvedData, allVisibleColumns, headerGroups, hasHeaderGroups, 
        // Sorted Data
        sortedData, } = resolvedState;
        // Pagination
        const startRow = pageSize * page;
        const endRow = startRow + pageSize;
        let pageRows = manual ? resolvedData : sortedData.slice(startRow, endRow);
        const minRows = this.getMinRows();
        const padRows = _.range(Math.max(minRows - pageRows.length, 0));
        const hasColumnFooter = allVisibleColumns.some(d => d.Footer);
        const hasFilters = filterable || allVisibleColumns.some(d => d.filterable);
        const recurseRowsViewIndex = (rows, path = [], index = -1) => [
            rows.map((row, i) => {
                index += 1;
                const rowWithViewIndex = Object.assign(Object.assign({}, row), { viewIndex: index });
                const newPath = path.concat([i]);
                if (rowWithViewIndex[subRowsKey] && _.get(expanded, newPath)) {
                    [rowWithViewIndex[subRowsKey], index] = recurseRowsViewIndex(rowWithViewIndex[subRowsKey], newPath, index);
                }
                return rowWithViewIndex;
            }),
            index,
        ];
        [pageRows] = recurseRowsViewIndex(pageRows);
        const canPrevious = page > 0;
        const canNext = page + 1 < pages;
        const rowMinWidth = _.sum(allVisibleColumns.map(d => {
            const resizedColumn = resized.find(x => x.id === d.id) || {
                id: undefined,
                value: undefined,
            };
            return _.getFirstDefined(resizedColumn.value, d.width, d.minWidth);
        }));
        let rowIndex = -1;
        const finalState = Object.assign(Object.assign({}, resolvedState), { startRow,
            endRow,
            pageRows,
            minRows,
            padRows,
            hasColumnFooter,
            canPrevious,
            canNext,
            rowMinWidth });
        const rootProps = getProps(finalState, undefined, undefined, this);
        const tableProps = getTableProps(finalState, undefined, undefined, this);
        const tBodyProps = getTbodyProps(finalState, undefined, undefined, this);
        const loadingProps = getLoadingProps(finalState, undefined, undefined, this);
        const noDataProps = getNoDataProps(finalState, undefined, undefined, this);
        // Visual Components
        const makeHeaderGroup = (column, i) => {
            const resizedValue = col => (resized.find(x => x.id === col.id) || {
                id: undefined,
                value: undefined,
            }).value;
            const flex = _.sum(column.columns.map(col => col.width || resizedValue(col) ? 0 : col.minWidth));
            const width = _.sum(column.columns.map(col => _.getFirstDefined(resizedValue(col), col.width, col.minWidth)));
            const maxWidth = _.sum(column.columns.map(col => _.getFirstDefined(resizedValue(col), col.width, col.maxWidth)));
            const theadGroupThProps = getTheadGroupProps(finalState, undefined, column, this);
            const columnHeaderProps = column.getHeaderProps(finalState, undefined, column, this);
            const rest = Object.assign(Object.assign(Object.assign({}, theadGroupThProps), columnHeaderProps), { CellTextComponent });
            const flexStyles = {
                flex: `${flex} 0 auto`,
                width: _.asPx(width),
                maxWidth: _.asPx(maxWidth),
            };
            return (React.createElement(ThComponent, Object.assign({ key: `${i}-${column.id}`, style: flexStyles }, rest), _.normalizeComponent(column.Header, {
                data: sortedData,
                column,
            })));
        };
        const selectRow = index => (nextRow, childIndex) => {
            const selectFirstAvailable = rows => {
                for (let i = 0; i < rows.length; i += 1) {
                    if (rows[i]) {
                        return rows[i].selectFirstChild(childIndex);
                    }
                }
                return false;
            };
            let found;
            if (typeof index === 'number') {
                const { page, pages } = this.state;
                if (nextRow) {
                    if (pageRows.length > index + 1) {
                        found = this.rowRef[index + 1].selectFirstChild(childIndex);
                    }
                    else if (page < pages - 1) {
                        this.onPageChange(page + 1);
                        found = true;
                    }
                    else {
                        found = selectFirstAvailable([this.footerRef]);
                    }
                }
                else if (index > 0) {
                    found = this.rowRef[index - 1].selectFirstChild(childIndex);
                }
                else if (page > 0) {
                    this.onPageChange(page - 1);
                    found = true;
                }
                else {
                    found = selectFirstAvailable([
                        this.filterRef,
                        this.headerRef,
                        this.headerGroupsRef,
                    ]);
                }
            }
            if (!found) {
                if (nextRow) {
                    focusNextElement(document);
                }
                else {
                    focusPrevElement(document);
                }
            }
        };
        const makeHeaderGroups = () => {
            const theadGroupProps = getTheadGroupProps(finalState, undefined, undefined, this);
            const theadGroupTrProps = getTheadGroupTrProps(finalState, undefined, undefined, this);
            return (React.createElement(TheadComponent, Object.assign({ style: { minWidth: `${rowMinWidth}px` } }, theadGroupProps),
                React.createElement(TrComponent, Object.assign({ ref: el => {
                        this.headerGroupsRef = el;
                    }, selectRow: selectRow('headerGroup') }, theadGroupTrProps), headerGroups.map(makeHeaderGroup))));
        };
        const makeHeader = (column, i) => {
            const resizedCol = resized.find(x => x.id === column.id) || {
                id: undefined,
                value: undefined,
            };
            const sort = sorted.find(d => d.id === column.id);
            const show = typeof column.show === 'function' ? column.show() : column.show;
            const width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
            const maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
            const theadThProps = getTheadThProps(finalState, undefined, column, this);
            const columnHeaderProps = column.getHeaderProps(finalState, undefined, column, this);
            const rest = Object.assign(Object.assign(Object.assign({}, theadThProps), columnHeaderProps), { CellTextComponent });
            const isResizable = _.getFirstDefined(column.resizable, resizable, false);
            const resizer = isResizable ? (React.createElement(ResizerComponent, Object.assign({ onMouseDown: e => this.resizeColumnStart(e, column, false), onTouchStart: e => this.resizeColumnStart(e, column, true) }, getResizerProps(finalState, undefined, column, this)))) : null;
            const isSortable = _.getFirstDefined(column.sortable, sortable, false);
            return (React.createElement(ThComponent, Object.assign({ key: `${i}-${column.id}`, sort: sort && (sort.desc ? '-sort-desc' : '-sort-asc'), resizable: isResizable, sortable: isSortable, hidden: !show, expander: column.expander, pivot: pivotBy && pivotBy.slice(0, -1).includes(column.id), style: {
                    flex: `${width} 0 auto`,
                    width: _.asPx(width),
                    maxWidth: _.asPx(maxWidth),
                }, toggleSort: e => {
                    if (isSortable)
                        this.sortColumn(column, multiSort ? e.shiftKey : false);
                } }, rest),
                _.normalizeComponent(column.Header, {
                    data: sortedData,
                    column,
                }),
                resizer));
        };
        const makeHeaders = () => {
            const theadProps = getTheadProps(finalState, undefined, undefined, this);
            const theadTrProps = getTheadTrProps(finalState, undefined, undefined, this);
            return (React.createElement(TheadComponent, Object.assign({ header: true, style: {
                    minWidth: `${rowMinWidth}px`,
                } }, theadProps),
                React.createElement(TrComponent, Object.assign({ ref: el => {
                        this.headerRef = el;
                    }, selectRow: selectRow('header') }, theadTrProps), allVisibleColumns.map(makeHeader))));
        };
        const makeFilter = (column, i) => {
            const resizedCol = resized.find(x => x.id === column.id) || {
                id: undefined,
                value: undefined,
            };
            const width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
            const maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
            const theadFilterThProps = getTheadFilterThProps(finalState, undefined, column, this);
            const filterInputProps = getFilterInputProps(finalState, undefined, column, this);
            const columnHeaderProps = column.getFilterProps(finalState, undefined, column, this);
            const rest = Object.assign(Object.assign(Object.assign({}, theadFilterThProps), columnHeaderProps), { CellTextComponent });
            const filter = filtered.find(filter => filter.id === column.id);
            const ResolvedFilterComponent = column.Filter || FilterComponent;
            const isFilterable = _.getFirstDefined(column.filterable, filterable, false);
            return (React.createElement(ThComponent, Object.assign({ key: `${i}-${column.id}`, style: {
                    flex: `${width} 0 auto`,
                    width: _.asPx(width),
                    maxWidth: _.asPx(maxWidth),
                } }, rest), isFilterable
                ? _.normalizeComponent(ResolvedFilterComponent, Object.assign(Object.assign({}, filterInputProps), { column,
                    filter, onChange: value => this.filterColumn(column, value) }), undefined)
                : null));
        };
        const makeFilters = () => {
            const theadFilterProps = getTheadFilterProps(finalState, undefined, undefined, this);
            const theadFilterTrProps = getTheadFilterTrProps(finalState, undefined, undefined, this);
            return (React.createElement(TheadComponent, Object.assign({ filters: true, style: {
                    minWidth: `${rowMinWidth}px`,
                } }, theadFilterProps),
                React.createElement(TrComponent, Object.assign({ ref: el => {
                        this.filterRef = el;
                    }, selectRow: selectRow('filter') }, theadFilterTrProps), allVisibleColumns.map(makeFilter))));
        };
        const makePageRow = (row, i, path = []) => {
            const rowInfo = {
                original: row[originalKey],
                row,
                index: row[indexKey],
                viewIndex: rowIndex += 1,
                pageSize,
                page,
                level: path.length,
                nestingPath: path.concat([i]),
                aggregated: row[aggregatedKey],
                groupedByPivot: row[groupedByPivotKey],
                subRows: row[subRowsKey],
            };
            const isExpanded = _.get(expanded, rowInfo.nestingPath);
            const trGroupProps = getTrGroupProps(finalState, rowInfo, undefined, this);
            const expanderProps = getExpanderProps(finalState, rowInfo, undefined, this);
            const trProps = getTrProps(row.viewIndex % 2, finalState, rowInfo, undefined, this);
            return (React.createElement(TrGroupComponent, Object.assign({ key: rowInfo.nestingPath.join('_') }, trGroupProps),
                React.createElement(TrComponent, Object.assign({ selectRow: selectRow(i), ref: el => {
                        this.rowRef[i] = el;
                    }, rowIndex: row.viewIndex }, trProps), allVisibleColumns.map((column, i2) => {
                    let defaultTdProps = {};
                    const resizedCol = resized.find(x => x.id === column.id) || {
                        id: undefined,
                        value: undefined,
                    };
                    const show = typeof column.show === 'function' ? column.show() : column.show;
                    const width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
                    const maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
                    const tdProps = getTdProps(finalState, rowInfo, column, this);
                    const columnProps = column.getProps(finalState, rowInfo, column);
                    const cellInfo = Object.assign(Object.assign(Object.assign(Object.assign({}, rowInfo), { isExpanded, column: Object.assign({}, column), value: rowInfo.row[column.id], pivoted: column.pivoted, expander: column.expander, expandable: undefined, resized,
                        show,
                        width,
                        maxWidth }), tdProps), columnProps);
                    let value = cellInfo.value;
                    let useOnExpanderClick;
                    let isBranch;
                    let isPreview;
                    const onExpanderClick = e => {
                        let newExpanded = _.clone(expanded);
                        if (isExpanded) {
                            newExpanded = _.set(newExpanded, cellInfo.nestingPath, false);
                        }
                        else {
                            newExpanded = _.set(newExpanded, cellInfo.nestingPath, {});
                        }
                        return this.setStateWithData({
                            expanded: newExpanded,
                        }, this.state, this.props, () => onExpandedChange &&
                            onExpandedChange(newExpanded, cellInfo.nestingPath, e));
                    };
                    // Default to a standard cell
                    if (column.Cell) {
                        value = _.normalizeComponent(column.Cell, cellInfo, value);
                    }
                    const cellProps = Object.assign(Object.assign({}, tdProps), columnProps);
                    let resolvedCell = (React.createElement(CellTextComponent, Object.assign({ value: value }, cellProps)));
                    // Resolve Renderers
                    const ResolvedAggregatedComponent = column.Aggregated ||
                        (!column.aggregate ? AggregatedComponent : column.Cell);
                    const ResolvedExpanderComponent = column.Expander || ExpanderComponent;
                    const ResolvedPivotValueComponent = column.PivotValue || PivotValueComponent;
                    const DefaultResolvedPivotComponent = PivotComponent ||
                        (props => (React.createElement(React.Fragment, null,
                            React.createElement(ResolvedExpanderComponent, Object.assign({}, Object.assign(Object.assign({}, props), { expanderProps }))),
                            React.createElement(ResolvedPivotValueComponent, Object.assign({}, props)))));
                    const ResolvedPivotComponent = column.Pivot || DefaultResolvedPivotComponent;
                    // Is this cell expandable?
                    if (cellInfo.pivoted || cellInfo.expander) {
                        // Make it expandable by defualt
                        cellInfo.expandable = true;
                        useOnExpanderClick = true;
                        // If pivoted, has no subRows, and does not have a subComponent,
                        // do not make expandable
                        if (cellInfo.pivoted && !cellInfo.subRows && !SubComponent) {
                            cellInfo.expandable = false;
                        }
                    }
                    if (cellInfo.pivoted) {
                        // Is this column a branch?
                        isBranch =
                            rowInfo.row[pivotIDKey] === column.id && cellInfo.subRows;
                        // Should this column be blank?
                        isPreview =
                            pivotBy.indexOf(column.id) >
                                pivotBy.indexOf(rowInfo.row[pivotIDKey]) &&
                                cellInfo.subRows;
                        // Pivot Cell Render Override
                        if (isBranch) {
                            // isPivot
                            resolvedCell = _.normalizeComponent(ResolvedPivotComponent, Object.assign(Object.assign({}, cellInfo), { value: row[pivotValKey] }), row[pivotValKey]);
                        }
                        else if (isPreview) {
                            // Show the pivot preview
                            resolvedCell = _.normalizeComponent(ResolvedAggregatedComponent, cellInfo, value);
                        }
                        else {
                            resolvedCell = null;
                        }
                    }
                    else if (cellInfo.aggregated) {
                        resolvedCell = _.normalizeComponent(ResolvedAggregatedComponent, cellInfo, value);
                    }
                    if (cellInfo.expander) {
                        defaultTdProps = expanderTdDefaultProps;
                        resolvedCell = _.normalizeComponent(ResolvedExpanderComponent, Object.assign(Object.assign({}, cellInfo), { expanderProps }), row[pivotValKey]);
                        if (pivotBy) {
                            if (cellInfo.groupedByPivot) {
                                resolvedCell = null;
                            }
                            if (!cellInfo.subRows && !SubComponent) {
                                resolvedCell = null;
                            }
                        }
                    }
                    const resolvedOnExpanderClick = useOnExpanderClick
                        ? onExpanderClick
                        : () => { };
                    // If there are multiple onClick events, make sure they don't
                    // override eachother. This should maybe be expanded to handle all
                    // function attributes
                    const interactionProps = {
                        onClick: resolvedOnExpanderClick,
                    };
                    if (tdProps.onClick) {
                        interactionProps.onClick = e => {
                            tdProps.onClick(e, () => resolvedOnExpanderClick(e));
                        };
                    }
                    if (columnProps.onClick) {
                        interactionProps.onClick = e => {
                            columnProps.onClick(e, () => resolvedOnExpanderClick(e));
                        };
                    }
                    // Return the cell
                    return (React.createElement(TdComponent
                    // eslint-disable-next-line react/no-array-index-key
                    , Object.assign({ 
                        // eslint-disable-next-line react/no-array-index-key
                        key: `${i2}-${column.id}`, hidden: !show, style: {
                            flex: `${width} 0 auto`,
                            width: _.asPx(width),
                            maxWidth: _.asPx(maxWidth),
                        } }, tdProps, columnProps, interactionProps, defaultTdProps), resolvedCell));
                })),
                rowInfo.subRows &&
                    isExpanded &&
                    rowInfo.subRows.map((d, i) => makePageRow(d, i, rowInfo.nestingPath)),
                SubComponent &&
                    !rowInfo.subRows &&
                    isExpanded &&
                    SubComponent(rowInfo)));
        };
        const makePadColumn = (column, i) => {
            const resizedCol = resized.find(x => x.id === column.id) || {
                id: undefined,
                value: undefined,
            };
            const show = typeof column.show === 'function' ? column.show() : column.show;
            const width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
            const flex = width;
            const maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
            const tdProps = getTdProps(finalState, undefined, column, this);
            return (React.createElement(TdComponent, Object.assign({ key: `${i}-${column.id}`, hidden: !show, style: {
                    flex: `${flex} 0 auto`,
                    width: _.asPx(width),
                    maxWidth: _.asPx(maxWidth),
                } }, tdProps), _.normalizeComponent(PadRowComponent)));
        };
        const makePadRow = (row, i) => {
            const trGroupProps = getTrGroupProps(finalState, undefined, undefined, this);
            const trProps = getTrProps(row.viewIndex % 2, finalState, undefined, undefined, this);
            return (React.createElement(TrGroupComponent, Object.assign({ key: i }, trGroupProps),
                React.createElement(TrComponent, Object.assign({ padrow: true, even: (pageRows.length + i) % 2 }, trProps), allVisibleColumns.map(makePadColumn))));
        };
        const makeColumnFooter = (column, i) => {
            const resizedCol = resized.find(x => x.id === column.id) || {
                id: undefined,
                value: undefined,
            };
            const show = typeof column.show === 'function' ? column.show() : column.show;
            const width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
            const maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
            const tFootTdProps = getTfootTdProps(finalState, undefined, undefined, this);
            const columnProps = column.getProps(finalState, undefined, column, this);
            const columnFooterProps = column.getFooterProps(finalState, undefined, column, this);
            return (React.createElement(TdComponent, Object.assign({ key: `${i}-${column.id}`, hidden: !show, style: {
                    flex: `${width} 0 auto`,
                    width: _.asPx(width),
                    maxWidth: _.asPx(maxWidth),
                } }, columnProps, tFootTdProps, columnFooterProps), _.normalizeComponent(column.Footer, {
                data: sortedData,
                column,
            })));
        };
        const makeColumnFooters = () => {
            const tFootProps = getTfootProps(finalState, undefined, undefined, this);
            const tFootTrProps = getTfootTrProps(finalState, undefined, undefined, this);
            return (React.createElement(TfootComponent, Object.assign({ style: {
                    minWidth: `${rowMinWidth}px`,
                } }, tFootProps),
                React.createElement(TrComponent, Object.assign({ ref: el => {
                        this.footerRef = el;
                    }, selectRow: selectRow('footer') }, tFootTrProps), allVisibleColumns.map(makeColumnFooter))));
        };
        const makePagination = () => {
            const paginationProps = getPaginationProps(finalState, undefined, undefined, this);
            return (React.createElement(PaginationComponent, Object.assign({}, resolvedState, { pages: pages, canPrevious: canPrevious, canNext: canNext, onPageChange: this.onPageChange, onPageSizeChange: this.onPageSizeChange }, paginationProps)));
        };
        const makeTable = () => {
            const pagination = makePagination();
            return (React.createElement("div", Object.assign({}, rootProps),
                showPagination && showPaginationTop ? React.createElement("div", null, pagination) : null,
                React.createElement(TableComponent, Object.assign({}, tableProps),
                    hasHeaderGroups ? makeHeaderGroups() : null,
                    makeHeaders(),
                    hasFilters ? makeFilters() : null,
                    React.createElement(TbodyComponent, Object.assign({ style: {
                            minWidth: `${rowMinWidth}px`,
                        } }, tBodyProps),
                        React.createElement(LoadingComponent, Object.assign({ loading: loading, loadingText: loadingText }, loadingProps)),
                        pageRows.map((d, i) => makePageRow(d, i)),
                        padRows.map(makePadRow)),
                    hasColumnFooter ? makeColumnFooters() : null),
                showPagination && showPaginationBottom ? (React.createElement("div", null, pagination)) : null,
                !pageRows.length && !loading && (React.createElement(NoDataComponent, Object.assign({}, noDataProps), _.normalizeComponent(noDataText)))));
        };
        // childProps are optionally passed to a function-as-a-child
        return makeTable();
    }
}
ReactTable.defaultProps = defaultProps;
ReactTable.getDataModel = (newState, props) => {
    const { columns, pivotBy = [], data, pivotIDKey, pivotValKey, subRowsKey, aggregatedKey, nestingLevelKey, originalKey, indexKey, groupedByPivotKey, SubComponent, } = newState;
    // Determine Header Groups
    let hasHeaderGroups = false;
    columns.forEach(column => {
        if (column.columns) {
            hasHeaderGroups = true;
        }
    });
    let columnsWithExpander = [...columns];
    let expanderColumn = columns.find(col => col.expander ||
        (col.columns && col.columns.some(col2 => col2.expander)));
    // The actual expander might be in the columns field of a group column
    if (expanderColumn && !expanderColumn.expander) {
        expanderColumn = expanderColumn.columns.find(col => col.expander);
    }
    // If we have SubComponent's we need to make sure we have an expander column
    if (SubComponent && !expanderColumn) {
        expanderColumn = { expander: true };
        columnsWithExpander = [expanderColumn, ...columnsWithExpander];
    }
    const makeDecoratedColumn = (column, parentColumn) => {
        let dcol;
        if (column.expander) {
            dcol = Object.assign(Object.assign(Object.assign({}, props.column), props.expanderDefaults), column);
        }
        else {
            dcol = Object.assign(Object.assign({}, props.column), column);
        }
        // Ensure minWidth is not greater than maxWidth if set
        if (dcol.maxWidth < dcol.minWidth) {
            dcol.minWidth = dcol.maxWidth;
        }
        if (parentColumn) {
            dcol.parentColumn = parentColumn;
        }
        // First check for string accessor
        if (typeof dcol.accessor === 'string') {
            dcol.id = dcol.id || dcol.accessor;
            const accessorString = dcol.accessor;
            dcol.accessor = row => _.get(row, accessorString);
            return dcol;
        }
        // Fall back to functional accessor (but require an ID)
        if (dcol.accessor && !dcol.id) {
            console.warn(dcol);
            throw new Error('A column id is required if using a non-string accessor for column above.');
        }
        // Fall back to an undefined accessor
        if (!dcol.accessor) {
            dcol.accessor = () => undefined;
        }
        return dcol;
    };
    const allDecoratedColumns = [];
    // Decorate the columns
    const decorateAndAddToAll = (column, parentColumn) => {
        const decoratedColumn = makeDecoratedColumn(column, parentColumn);
        allDecoratedColumns.push(decoratedColumn);
        return decoratedColumn;
    };
    const decoratedColumns = columnsWithExpander.map(column => {
        if (column.columns) {
            return Object.assign(Object.assign({}, column), { columns: column.columns.map(d => decorateAndAddToAll(d, column)) });
        }
        return decorateAndAddToAll(column);
    });
    // Build the visible columns, headers and flat column list
    let visibleColumns = decoratedColumns.slice();
    let allVisibleColumns = [];
    visibleColumns = visibleColumns.map(column => {
        if (column.columns) {
            const visibleSubColumns = column.columns.filter(d => pivotBy.indexOf(d.id) > -1 ? false : _.getFirstDefined(d.show, true));
            return Object.assign(Object.assign({}, column), { columns: visibleSubColumns });
        }
        return column;
    });
    visibleColumns = visibleColumns.filter(column => column.columns
        ? column.columns.length
        : pivotBy.indexOf(column.id) > -1
            ? false
            : _.getFirstDefined(column.show, true));
    // Find any custom pivot location
    const pivotIndex = visibleColumns.findIndex(col => col.pivot);
    // Handle Pivot Columns
    if (pivotBy.length) {
        // Retrieve the pivot columns in the correct pivot order
        const pivotColumns = [];
        pivotBy.forEach(pivotID => {
            const found = allDecoratedColumns.find(d => d.id === pivotID);
            if (found) {
                pivotColumns.push(found);
            }
        });
        const PivotParentColumn = pivotColumns.reduce((prev, current) => prev && prev === current.parentColumn && current.parentColumn, pivotColumns[0].parentColumn);
        const PivotGroupHeader = hasHeaderGroups &&
            (PivotParentColumn
                ? PivotParentColumn.Header
                : pivotColumns[0].PivotHeader || pivotColumns[0].Header);
        let pivotColumnGroup = {
            Header: PivotGroupHeader,
            columns: pivotColumns.map(col => (Object.assign(Object.assign(Object.assign({}, props.pivotDefaults), col), { pivoted: true }))),
        };
        // Place the pivotColumns back into the visibleColumns
        if (pivotIndex >= 0) {
            pivotColumnGroup = Object.assign(Object.assign({}, visibleColumns[pivotIndex]), pivotColumnGroup);
            visibleColumns.splice(pivotIndex, 1, pivotColumnGroup);
        }
        else {
            visibleColumns.unshift(pivotColumnGroup);
        }
    }
    // Build Header Groups
    const headerGroups = [];
    let currentSpan = [];
    // A convenience function to add a header and reset the currentSpan
    const addHeader = (columns, column) => {
        headerGroups.push(Object.assign(Object.assign(Object.assign({}, props.column), column), { columns }));
        currentSpan = [];
    };
    // Build flast list of allVisibleColumns and HeaderGroups
    visibleColumns.forEach(column => {
        if (column.columns) {
            allVisibleColumns = allVisibleColumns.concat(column.columns);
            if (currentSpan.length > 0) {
                addHeader(currentSpan);
            }
            addHeader(column.columns, column);
            return;
        }
        allVisibleColumns.push(column);
        currentSpan.push(column);
    });
    if (hasHeaderGroups && currentSpan.length > 0) {
        addHeader(currentSpan);
    }
    // Access the data
    const accessRow = (d, i, level = 0) => {
        const row = {
            [originalKey]: d,
            [indexKey]: i,
            [subRowsKey]: d[subRowsKey],
            [nestingLevelKey]: level,
        };
        allDecoratedColumns.forEach(column => {
            if (column.expander)
                return;
            row[column.id] = column.accessor(d);
        });
        if (row[subRowsKey]) {
            row[subRowsKey] = row[subRowsKey].map((d, i) => accessRow(d, i, level + 1));
        }
        return row;
    };
    let resolvedData = data.map((d, i) => accessRow(d, i));
    const aggregatingColumns = allVisibleColumns.filter(d => !d.expander && d.aggregate);
    // If pivoting, recursively group the data
    const aggregate = rows => {
        const aggregationValues = {};
        aggregatingColumns.forEach(column => {
            const values = rows.map(d => d[column.id]);
            aggregationValues[column.id] = column.aggregate(values, rows);
        });
        return aggregationValues;
    };
    if (pivotBy.length) {
        const groupRecursively = (rows, keys, i = 0) => {
            // This is the last level, just return the rows
            if (i === keys.length) {
                return rows;
            }
            // Group the rows together for this level
            let groupedRows = Object.entries(_.groupBy(rows, keys[i])).map(([key, value]) => ({
                [pivotIDKey]: keys[i],
                [pivotValKey]: key,
                [keys[i]]: key,
                [subRowsKey]: value,
                [nestingLevelKey]: i,
                [groupedByPivotKey]: true,
            }));
            // Recurse into the subRows
            groupedRows = groupedRows.map(rowGroup => {
                const subRows = groupRecursively(rowGroup[subRowsKey], keys, i + 1);
                return Object.assign(Object.assign(Object.assign({}, rowGroup), { [subRowsKey]: subRows, [aggregatedKey]: true }), aggregate(subRows));
            });
            return groupedRows;
        };
        resolvedData = groupRecursively(resolvedData, pivotBy);
    }
    return Object.assign(Object.assign({}, newState), { resolvedData,
        allVisibleColumns,
        headerGroups,
        allDecoratedColumns,
        hasHeaderGroups });
};
ReactTable.getSortedData = (resolvedState, props) => {
    const { manual, sorted, filtered, defaultFilterMethod, resolvedData, allVisibleColumns, allDecoratedColumns, } = resolvedState;
    const sortMethodsByColumnID = {};
    allDecoratedColumns
        .filter(col => col.sortMethod)
        .forEach(col => {
        sortMethodsByColumnID[col.id] = col.sortMethod;
    });
    // Resolve the data from either manual data or sorted data
    return {
        sortedData: manual
            ? resolvedData
            : ReactTable.sortData(ReactTable.filterData(resolvedData, filtered, defaultFilterMethod, allVisibleColumns, props), sorted, sortMethodsByColumnID, props),
    };
};
ReactTable.filterData = (data, filtered, defaultFilterMethod, allVisibleColumns, props) => {
    let filteredData = data;
    if (filtered.length) {
        filteredData = filtered.reduce((filteredSoFar, nextFilter) => {
            const column = allVisibleColumns.find(x => x.id === nextFilter.id);
            // Don't filter hidden columns or columns that have had their filters disabled
            if (!column || column.filterable === false) {
                return filteredSoFar;
            }
            const filterMethod = column.filterMethod || defaultFilterMethod;
            // If 'filterAll' is set to true, pass the entire dataset to the filter method
            if (column.filterAll) {
                return filterMethod(nextFilter, filteredSoFar, column);
            }
            return filteredSoFar.filter(row => filterMethod(nextFilter, row, column));
        }, filteredData);
        // Apply the filter to the subrows if we are pivoting, and then
        // filter any rows without subcolumns because it would be strange to show
        filteredData = filteredData
            .map(row => {
            if (!row[props.subRowsKey]) {
                return row;
            }
            return Object.assign(Object.assign({}, row), { [props.subRowsKey]: ReactTable.filterData(row[props.subRowsKey], filtered, defaultFilterMethod, allVisibleColumns, props) });
        })
            .filter(row => {
            if (!row[props.subRowsKey]) {
                return true;
            }
            return row[props.subRowsKey].length > 0;
        });
    }
    return filteredData;
};
ReactTable.sortData = (data, sorted, sortMethodsByColumnID = {}, props) => {
    if (!sorted.length) {
        return data;
    }
    const sortedData = _.orderBy(data, sorted.map(sort => {
        // Support custom sorting methods for each column
        if (sortMethodsByColumnID[sort.id]) {
            return (a, b) => sortMethodsByColumnID[sort.id](a[sort.id], b[sort.id], sort.desc);
        }
        return (a, b) => props.defaultSortMethod(a[sort.id], b[sort.id], sort.desc);
    }), sorted.map(d => !d.desc), props.indexKey);
    sortedData.forEach(row => {
        if (!row[props.subRowsKey]) {
            return;
        }
        row[props.subRowsKey] = ReactTable.sortData(row[props.subRowsKey], sorted, sortMethodsByColumnID, props);
    });
    return sortedData;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVhY3RUYWJsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1BhZ2luZ1RhYmxlL3JlYWN0LXRhYmxlL1JlYWN0VGFibGUudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzBDQUMwQztBQUMxQyxPQUFPLEtBQUssRUFBRSxFQUFFLFNBQVMsRUFBRSxNQUFNLE9BQU8sQ0FBQztBQUN6QyxPQUFPLENBQUMsTUFBTSxTQUFTLENBQUM7QUFDeEIsT0FBTyxZQUFZLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLE1BQU0sUUFBUSxDQUFDO0FBUTVELE1BQU0sQ0FBQyxPQUFPLE9BQU8sVUFBVyxTQUFRLFNBR3ZDO0lBYUMsWUFBWSxLQUFLO1FBQ2YsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBWGYsV0FBTSxHQUFHLEVBQUUsQ0FBQztRQUVaLGNBQVMsR0FBRyxJQUFJLENBQUM7UUFFakIsY0FBUyxHQUFHLElBQUksQ0FBQztRQUVqQixjQUFTLEdBQUcsSUFBSSxDQUFDO1FBRWpCLG9CQUFlLEdBQUcsSUFBSSxDQUFDO1FBaUJ2QixxQkFBZ0IsR0FBRyxDQUNqQixLQUF5QixFQUN6QixLQUF5QixFQUNOLEVBQUUsQ0FBQyw2REFDbkIsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQzNCLENBQUMsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUMzQixDQUFDLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxHQUN0QixDQUFDLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxFQUN6QixDQUFDO1FBdWVILGtCQUFhLEdBQUcsR0FBRyxFQUFFO1lBQ25CLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3hELENB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