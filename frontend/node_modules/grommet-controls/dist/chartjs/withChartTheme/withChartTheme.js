var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React from 'react';
import { ThemeContext } from 'grommet';
import { normalizeColor, getRGBA } from 'grommet/utils/colors';
import { deepMerge } from 'grommet/utils/object';
import { colorFromIndex, colorForName } from '../../utils/colors';
const normalizedColor = (color, theme) => colorForName(normalizeColor(color, theme), theme);
export const withChartTheme = (WrappedComponent, _a = {}) => {
    var { classOpacity = 0.6, defaultScales = [{}] } = _a, other = __rest(_a, ["classOpacity", "defaultScales"]);
    return ({ options, data }) => (React.createElement(ThemeContext.Consumer, null, theme => {
        const textColor = normalizedColor('text', theme);
        const axisColors = {
            ticks: {
                fontColor: textColor,
            },
            gridLines: {
                color: normalizedColor('border', theme),
            },
            scaleLabel: {
                fontColor: textColor,
            },
        };
        const defaultOptions = {
            maintainAspectRatio: false,
            title: {
                fontColor: textColor,
            },
            legend: {
                labels: {
                    fontColor: textColor,
                },
            },
            scales: {},
        };
        const themedOptions = deepMerge(defaultOptions, options);
        themedOptions.scales.xAxes = themedOptions.scales.xAxes || defaultScales;
        themedOptions.scales.yAxes = themedOptions.scales.yAxes || defaultScales;
        themedOptions.scales.xAxes = themedOptions.scales.xAxes.map(x => deepMerge(axisColors, x));
        themedOptions.scales.yAxes = themedOptions.scales.yAxes.map(y => deepMerge(axisColors, y));
        let datasets;
        if (data && Array.isArray(data.datasets)) {
            datasets = data.datasets.map((dataset, i) => {
                const { backgroundColor, borderColor, color } = dataset, rest = __rest(dataset, ["backgroundColor", "borderColor", "color"]);
                let newOpts;
                const themeColors = (index, itemOpacity) => {
                    const lineColor = borderColor || color || colorFromIndex(index);
                    const lineColors = Array.isArray(lineColor)
                        ? lineColor.map(c => normalizedColor(c, theme))
                        : normalizedColor(lineColor, theme);
                    const fillColor = backgroundColor || lineColor;
                    const opacity = itemOpacity ||
                        dataset.opacity ||
                        (options && options.opacity) ||
                        classOpacity;
                    const fillColors = Array.isArray(fillColor)
                        ? fillColor.map(c => getRGBA(normalizedColor(c, theme), opacity))
                        : getRGBA(normalizedColor(fillColor, theme), opacity);
                    return {
                        backgroundColor: fillColors,
                        borderColor: lineColors,
                    };
                };
                if (options && options.themedData && dataset.data) {
                    newOpts = { backgroundColor: [], borderColor: [] };
                    dataset.data.forEach((dataRow, rIndex) => {
                        const colors = themeColors(rIndex, dataRow.opacity);
                        newOpts.backgroundColor.push(colors.backgroundColor);
                        newOpts.borderColor.push(colors.borderColor);
                    });
                }
                else {
                    newOpts = themeColors(i);
                }
                return Object.assign(Object.assign(Object.assign({}, newOpts), other), rest);
            });
        }
        return (React.createElement(WrappedComponent, { options: themedOptions, data: Object.assign(Object.assign({}, data), { datasets }) }));
    }));
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2l0aENoYXJ0VGhlbWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY2hhcnRqcy93aXRoQ2hhcnRUaGVtZS93aXRoQ2hhcnRUaGVtZS50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxPQUFPLEtBQUssTUFBTSxPQUFPLENBQUM7QUFDMUIsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUN2QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE9BQU8sRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQy9ELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsY0FBYyxFQUFFLFlBQVksRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBTWxFLE1BQU0sZUFBZSxHQUFHLENBQUMsS0FBVSxFQUFFLEtBQVUsRUFBRSxFQUFFLENBQ2pELFlBQVksQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBRXBELE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBRyxDQUM1QixnQkFBZ0IsRUFDaEIsS0FJeUIsRUFBRSxFQUVMLEVBQUU7UUFOeEIsRUFDRSxZQUFZLEdBQUcsR0FBRyxFQUNsQixhQUFhLEdBQUcsQ0FBQyxFQUFFLENBQUMsT0FFSyxFQUR0QixLQUFLLGNBSFYsaUNBSUMsQ0FEUztJQUdlLE9BQUEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FDaEQsb0JBQUMsWUFBWSxDQUFDLFFBQVEsUUFDbkIsS0FBSyxDQUFDLEVBQUU7UUFDUCxNQUFNLFNBQVMsR0FBRyxlQUFlLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ2pELE1BQU0sVUFBVSxHQUFHO1lBQ2pCLEtBQUssRUFBRTtnQkFDTCxTQUFTLEVBQUUsU0FBUzthQUNyQjtZQUNELFNBQVMsRUFBRTtnQkFDVCxL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