import { __rest } from 'tslib';
import React, { Component, useContext, useEffect } from 'react';
import { Box, Text, Heading, FormField, CheckBox, TextInput, DropButton, Button, Keyboard, Calendar, Meter, Select, ResponsiveContext, TextArea } from 'grommet';
import styled, { ThemeContext, css, keyframes } from 'styled-components';
import { controlBorderStyle, edgeStyle } from 'grommet/utils/styles';
import { deepMerge } from 'grommet/utils/object';
import { StopFill } from 'grommet-icons';
import { findDOMNode } from 'react-dom';
import { conformToMask, createTextMaskInputElement } from 'text-mask-core';
import { createAutoCorrectedDatePipe, emailMask, createNumberMask } from 'text-mask-addons';
import { FormDown } from 'grommet-icons/icons/FormDown';
import { parseMetricToNum } from 'grommet/utils/mixins';
import { normalizeColor } from 'grommet/utils/colors';
import { Calendar as Calendar$1 } from 'grommet-icons/icons/Calendar';
import { Close } from 'grommet-icons/icons/Close';
import { StatusGood } from 'grommet-icons/icons/StatusGood';
import { StatusWarning } from 'grommet-icons/icons/StatusWarning';
import { StatusCritical } from 'grommet-icons/icons/StatusCritical';
import { StatusUnknown } from 'grommet-icons/icons/StatusUnknown';
import { StatusInfo } from 'grommet-icons/icons/StatusInfo';
import { StatusDisabled } from 'grommet-icons/icons/StatusDisabled';
import { Add } from 'grommet-icons/icons/Add';
import { Subtract } from 'grommet-icons/icons/Subtract';
import { FormView } from 'grommet-icons/icons/FormView';
import { Hide } from 'grommet-icons/icons/Hide';
import { Previous } from 'grommet-icons/icons/Previous';
import { Next } from 'grommet-icons/icons/Next';
import { Blank } from 'grommet-icons/icons/Blank';
import { LinkDown } from 'grommet-icons/icons/LinkDown';
import { LinkUp } from 'grommet-icons/icons/LinkUp';
import { Menu } from 'grommet-icons/icons/Menu';
import { FormClose } from 'grommet-icons/icons/FormClose';
import { backgroundStyle } from 'grommet/utils/background';
import { FormNext } from 'grommet-icons/icons/FormNext';
export { a as colorForName, c as colorFromIndex } from './colors.esm.js';

const ROUND_MAP = {
    full: '100%',
};
const StyledImageStamp = styled.img `
  ${props => !props.plain && controlBorderStyle};
  ${props => (!props.contain || props.contain === 'width') &&
    props.size &&
    edgeStyle('width', props.size, false, undefined, props.theme)}
  ${props => (!props.contain || props.contain === 'height') &&
    props.size &&
    edgeStyle('height', props.size, false, undefined, props.theme)}
  overflow: hidden;
  object-fit: cover;
  border-radius: ${props => ROUND_MAP[props.round] || props.theme.global.edgeSize[props.round]};
  -webkit-border-radius: ${props => ROUND_MAP[props.round] || props.theme.global.edgeSize[props.round]};
  -moz-border-radius: ${props => ROUND_MAP[props.round] || props.theme.global.edgeSize[props.round]};
`;

const SIZE_MAP = {
    small: 'medium',
    medium: 'large',
    large: 'xlarge',
    xlarge: 'xxlarge',
};
/**
 *  A small image stamp used for avatars or image thumbnails
 */
const ImageStamp = (_a) => {
    var { size, src } = _a, rest = __rest(_a, ["size", "src"]);
    return src ? React.createElement(StyledImageStamp, Object.assign({ src: src, size: SIZE_MAP[size] }, rest)) : null;
};
ImageStamp.defaultProps = {
    contain: null,
    size: 'medium',
    plain: false,
};

/**
 * An image with some text, can be used as a user Avatar image<br/>
 * `import { Avatar } from 'grommet-controls;'`<br/>
 * `<Avatar image='...' />`<br/>
 */
const Avatar = (_a) => {
    var { image, title, subTitle } = _a, rest = __rest(_a, ["image", "title", "subTitle"]);
    return (React.createElement(Box, { direction: "row", align: "center", gap: "small" },
        React.createElement(ImageStamp, Object.assign({ src: image, round: "full" }, rest)),
        React.createElement(Box, { justify: "between" },
            React.createElement(Text, { weight: "bold", truncate: true }, title),
            React.createElement(Text, { size: "small", truncate: true }, subTitle))));
};

const white = '#ffffff';
const silver = '#c0c0c0';
const gray = '#808080';
const black = '#000000';
const red = '#ff0000';
const maroon = '#800000';
const yellow = '#ffff00';
const olive = '#808000';
const lime = '#00ff00';
const green = '#008000';
const aqua = '#00ffff';
const teal = '#008080';
const blue = '#0000ff';
const navy = '#000080';
const fuchsia = '#ff00ff';
const purple = '#800080';
const basicColors = {
    white,
    silver,
    gray,
    black,
    red,
    maroon,
    yellow,
    olive,
    lime,
    green,
    aqua,
    teal,
    blue,
    navy,
    fuchsia,
    purple,
};

const StyledCard = styled(Box) `
  @media (max-width: ${props => props.theme.global.breakpoints.small}px) {
    flex-basis: 100%;
  }
`;

/**
 * A Card-type container, all props of Box apply<br/>
 * `import { Card } from 'grommet-controls';`<br/>
 * `<Card>`<br/>
 * &nbsp;&nbsp;`<Card.CardTitle>`<br/>
 * &nbsp;&nbsp;&nbsp;&nbsp;`Title`<br/>
 * &nbsp;&nbsp;`</Card.CardTitle>`<br/>
 * &nbsp;&nbsp;`<Card.CardContent>`<br/>
 * &nbsp;&nbsp;&nbsp;&nbsp;`card content goes here`<br/>
 * &nbsp;&nbsp;`</Card.CardContent>`<br/>
 * `</Card>`<br/>
 */
const Card = (_a) => {
    var { children } = _a, rest = __rest(_a, ["children"]);
    return (React.createElement(ThemeContext.Consumer, null, theme => (React.createElement(StyledCard, Object.assign({ theme: theme, overflow: "hidden" }, rest), children))));
};
Card.displayName = 'Card';
Card.defaultProps = {
    align: 'center',
    border: 'all',
    elevation: 'small',
    round: 'xsmall',
    flex: false,
    gap: 'small',
    fill: 'horizontal',
    background: 'white',
};
/**
 *  Card Actions to be placed at the bottom of the Card
 */
const CardActions = (_a) => {
    var { children, pad = 'small' } = _a, rest = __rest(_a, ["children", "pad"]);
    return (React.createElement(Box, Object.assign({ align: "center", pad: pad, gap: "small", border: "top", flex: false, fill: "horizontal", direction: "row" }, rest), children));
};
CardActions.displayName = 'CardActions';
Card.CardActions = CardActions;
/**
 *  Card Title display the card title
 */
const CardTitle = (_a) => {
    var { children, color, textAlign, truncate, level = 4, strong = false, responsive } = _a, rest = __rest(_a, ["children", "color", "textAlign", "truncate", "level", "strong", "responsive"]);
    return (React.createElement(Box, Object.assign({ direction: "row", fill: "horizontal", border: "bottom", gap: "small", flex: false }, rest), typeof children !== 'string' ? (children) : (React.createElement(Heading, { level: level, margin: "none", color: color, textAlign: textAlign, truncate: truncate, responsive: responsive }, strong ? React.createElement("strong", null, children) : children))));
};
CardTitle.displayName = 'CardTitle';
Card.CardTitle = CardTitle;
/**
 *  Card Content
 */
const CardContent = (_a) => {
    var { children, pad = 'small' } = _a, rest = __rest(_a, ["children", "pad"]);
    return (React.createElement(Box, Object.assign({ pad: pad, fill: true, flex: true }, rest), children));
};
CardContent.displayName = 'CardContent';
Card.CardContent = CardContent;

const StyledForm = styled.form `
  width: 100%;
`;

const filterByFocusable = elements => Array.prototype.filter.call(elements || [], element => {
    const currentTag = element.tagName.toLowerCase();
    const validTags = /(svg|a|area|input|select|textarea|button|iframe|div)$/;
    const isValidTag = currentTag.match(validTags) && element.focus;
    if (currentTag === 'a') {
        return (isValidTag &&
            element.childNodes.length > 0 &&
            element.getAttribute('href'));
    }
    if (currentTag === 'svg' || currentTag === 'div') {
        return (isValidTag &&
            element.hasAttribute('tabindex') &&
            element.getAttribute('tabindex') !== '-1');
    }
    return isValidTag;
});

const FormContext = React.createContext({
    attachToForm: null,
    detachFromForm: null,
    getFieldValue: null,
    getFieldErrors: null,
    onFieldChange: null,
});
const styledComponents = {
    form: StyledForm,
};
/** A Form with built-in validation<br/>
 *`import { Form } from 'grommet-controls';`<br/>
 *`<Form onSubmit={...} />`<br/>
 */
class Form extends Component {
    constructor(props) {
        super(props);
        this.fields = {};
        this.containerRef = React.createRef();
        this.validate = (data) => {
            const errors = {};
            const addError = (key, field, message) => {
                if (!errors[key]) {
                    errors[key] = [];
                }
                let msg;
                if (typeof message === 'function') {
                    msg = message(field.description || field.label || key);
                }
                else {
                    msg = message;
                }
                errors[key].push(msg);
            };
            Object.keys(this.fields).forEach(key => {
                const field = this.fields[key];
                let rules = field.validation;
                if (rules) {
                    if (!Array.isArray(rules)) {
                        rules = [rules];
                    }
                    for (let i = 0; i < rules.length; i += 1) {
                        const rule = rules[i];
                        if (typeof rule === 'function') {
                            const value = data[key];
                            if (Array.isArray(value)) {
                                const arrayErrors = [];
                                value.forEach((_v, index) => {
                                    const message = rule(data, data[key], index);
                                    if (message) {
                                        arrayErrors[index] = message;
                                    }
                                });
                                if (arrayErrors.length) {
                                    addError(key, field, arrayErrors);
                                }
                            }
                            else {
                                const message = rule(data, data[key]);
                                if (message) {
                                    addError(key, field, message);
                                }
                            }
                        }
                        else if (rule !== null && typeof rule === 'object') {
                            if (rule.rule && typeof rule.rule === 'function') {
                                const isValid = rule.rule(data, data[key]);
                                if (!isValid) {
                                    if (typeof rule.message === 'function') {
                                        addError(key, field, rule.message(typeof field.label === 'string' ? field.label : key));
                                    }
                                    else {
                                        addError(key, field, rule.message);
                                    }
                                }
                            }
                        }
                    }
                }
            });
            if (Object.keys(errors).length === 0) {
                return undefined;
            }
            return errors;
        };
        this.onSubmit = event => {
            const { onSubmit, onSubmitError } = this.props;
            const { data } = this.state;
            event.preventDefault();
            const errors = this.validate(data);
            if (!errors) {
                if (onSubmit) {
                    onSubmit(data);
                }
            }
            else {
                if (onSubmitError) {
                    onSubmitError(errors);
                }
                this.setState({ errors, submitted: true });
            }
        };
        this.updateObject = (name, value, e) => {
            this.setState(prevState => {
                const data = Object.assign(Object.assign({}, prevState.data), { [name]: value });
                const { submitted } = this.state;
                const errors = this.validate(data);
                if (this.props.onChange) {
                    this.props.onChange(name, value, e);
                }
                if (errors) {
                    if (this.props.onInvalidForm) {
                        this.props.onInvalidForm(data);
                    }
                }
                else if (this.props.onValidForm) {
                    this.props.onValidForm(data);
                }
                return { data, errors: submitted ? errors : prevState.errors };
            });
        };
        this.attachToForm = (name, props) => {
            this.fields = Object.assign(Object.assign({}, this.fields), { [name]: props });
        };
        this.detachFromForm = name => {
            delete this.fields[name];
        };
        this.getFieldValue = name => this.state.data[name];
        this.getFieldErrors = name => (this.state.errors ? this.state.errors[name] : null);
        this.state = {
            errors: undefined,
            submitted: false,
            data: Object.assign(Object.assign({}, props.initialValues), props.object),
        };
    }
    static getDerivedStateFromProps(nextProps, prevState) {
        if (JSON.stringify(nextProps.object) !== JSON.stringify(prevState.data)) {
            return {
                data: deepMerge(prevState.data, nextProps.object),
            };
        }
        return null;
    }
    componentDidMount() {
        const { focusFirstChild } = this.props;
        if (focusFirstChild) {
            let items = this.containerRef.current.getElementsByTagName('*');
            items = filterByFocusable(items);
            if (items.length > 0) {
                setTimeout(() => {
                    // @ts-ignore
                    items[0].focus();
                }, 0);
            }
        }
    }
    render() {
        const _a = this.props, { 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onSubmitError, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onValidForm, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onInvalidForm, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onSubmit, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onChange, className, children, a11yTitle, tag } = _a, rest = __rest(_a, ["onSubmitError", "onValidForm", "onInvalidForm", "onSubmit", "onChange", "className", "children", "a11yTitle", "tag"]);
        let StyledComponent = styledComponents[tag];
        if (!StyledComponent) {
            StyledComponent = StyledForm.withComponent(tag);
            styledComponents[tag] = StyledComponent;
        }
        return (React.createElement(StyledComponent, { className: className, onSubmit: this.onSubmit, "aria-label": a11yTitle },
            React.createElement(Box, { direction: "row" },
                React.createElement(Box, Object.assign({}, rest),
                    React.createElement("div", { ref: this.containerRef },
                        React.createElement(FormContext.Provider, { value: {
                                attachToForm: this.attachToForm,
                                detachFromForm: this.detachFromForm,
                                getFieldValue: this.getFieldValue,
                                getFieldErrors: this.getFieldErrors,
                                onFieldChange: this.updateObject,
                            } }, children))))));
    }
}
Form.defaultProps = {
    focusFirstChild: true,
    onChange: undefined,
    onSubmit: undefined,
    onSubmitError: undefined,
    onInvalidForm: undefined,
    onValidForm: undefined,
    initialValues: {},
    object: {},
    tag: 'form',
    basis: 'medium',
};

const WithFormField = (_a) => {
    var { validation, label, description, name, controlLabel, inField, children } = _a, other = __rest(_a, ["validation", "label", "description", "name", "controlLabel", "inField", "children"]);
    const form = useContext(FormContext);
    const { onFieldChange, getFieldValue, getFieldErrors } = form;
    useEffect(() => {
        form.attachToForm(name, { label, description, validation });
        return () => {
            form.detachFromForm(name);
        };
    });
    const onChange = e => {
        const { value, target } = e;
        const targetValue = target ? target.value : undefined;
        onFieldChange(name, value || targetValue, e);
    };
    const getValue = () => {
        const value = getFieldValue(name);
        return value === undefined ? '' : value;
    };
    const errors = getFieldErrors(name);
    let error = Array.isArray(errors) ? errors[0] : errors;
    if (typeof error === 'function') {
        error = error(typeof label === 'string' ? label : name);
    }
    const field = children(Object.assign({ id: name, name, label: inField ? controlLabel : label, value: getValue(), onChange }, other));
    if (!inField) {
        return field;
    }
    return (React.createElement(FormField, { htmlFor: name, label: label || (controlLabel === true && name), error: error }, field));
};
WithFormField.defaultProps = {
    validation: undefined,
    inField: true,
    controlLabel: undefined,
    label: undefined,
    description: undefined,
    Control: React.Component,
};

const CheckBoxField = (props) => (React.createElement(WithFormField, Object.assign({}, props), (_a) => {
    var { value, onChange } = _a, rest = __rest(_a, ["value", "onChange"]);
    return (React.createElement(Box, { pad: { vertical: 'small' } },
        React.createElement(CheckBox, Object.assign({ checked: value === true, onChange: onChange ? () => onChange({ target: { value: !value } }) : undefined }, rest))));
}));

/* eslint-disable no-mixed-operators */
const StyledDropInput = styled(TextInput) `
  padding-right: ${props => {
    const widgetsBox = props.numWidgets *
        (24 + 2 * parseMetricToNum(props.theme.global.edgeSize.small));
    // eslint-disable-next-line no-mixed-operators
    return (widgetsBox +
        parseMetricToNum(props.theme.global.spacing) / 2 -
        parseMetricToNum(props.theme.global.control.border.width));
}}px;
`;
const StyledDropInputContainer = styled.div `
  position: relative;
  width: 100%;
  cursor: pointer;
`;
const StyledWidgetsContainer = styled(Box) `
  position: absolute;
  right: 0;
  top: 0;
`;

/**
 *  An Input control with an optional drop button with the specified 'dropContent' or widgets<br/>
 *`import { DropInput } from 'grommet-controls';`<br/>
 *`<DropInput`<br/>
 *&nbsp;&nbsp;`dropContent={(`<br/>
 *&nbsp;&nbsp;&nbsp;&nbsp;`...`<br/>
 *&nbsp;&nbsp;`]}`<br/>
 *`/>`<br/>
 */
class DropInput extends Component {
    constructor() {
        super(...arguments);
        this.state = { open: false };
        this.inputRef = React.createRef();
        this.onUpdateValue = value => {
            const { onChange } = this.props;
            // eslint-disable-next-line react/no-find-dom-node
            const input = findDOMNode(this.inputRef.current);
            input.value = value;
            this.setState({ open: false, value });
            if (onChange) {
                onChange({ target: input });
            }
        };
        this.onOpen = e => {
            const { onOpen, disabled } = this.props;
            this.setState({ open: true });
            if (onOpen && !disabled) {
                onOpen(e);
            }
        };
        this.onClose = e => {
            const { onClose, disabled } = this.props;
            this.setState({ open: false });
            if (onClose && !disabled) {
                onClose(e);
            }
        };
        this.onKeyDown = e => {
            const { onKeyDown } = this.props;
            this.setState({ open: true });
            if (onKeyDown) {
                onKeyDown(e);
            }
        };
        this.onKeyUp = e => {
            const { onKeyUp } = this.props;
            this.setState({ open: false });
            if (onKeyUp) {
                onKeyUp(e);
            }
        };
    }
    static getDerivedStateFromProps(newProps, oldState) {
        if (newProps.value !== oldState.value ||
            newProps.defaultValue !== oldState.defaultValue) {
            return {
                value: newProps.value,
                defaultValue: newProps.defaultValue,
                open: false,
            };
        }
        return null;
    }
    render() {
        const _a = this.props, { a11yTitle, a11yDropTitle, dropAlign, dropTarget, update, widgets, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onOpen, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onClose, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onKeyDown, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onKeyUp, defaultValue, dropContent, dropIcon, disabled } = _a, rest = __rest(_a, ["a11yTitle", "a11yDropTitle", "dropAlign", "dropTarget", "update", "widgets", "onOpen", "onClose", "onKeyDown", "onKeyUp", "defaultValue", "dropContent", "dropIcon", "disabled"]);
        const { open } = this.state;
        if (typeof update === 'function') {
            update(this.onUpdateValue);
        }
        const numWidgets = (dropContent ? 1 : 0) + (widgets ? widgets.length : 0);
        let decorations;
        if (numWidgets > 0) {
            let drop;
            if (dropContent) {
                drop = (React.createElement(DropButton, { a11yTitle: a11yDropTitle, disabled: disabled, dropAlign: dropAlign, dropTarget: dropTarget, open: open, tabIndex: -1, focusIndicator: false, onOpen: this.onOpen, onClose: this.onClose, dropContent: dropContent, icon: dropIcon }));
            }
            decorations = (React.createElement(StyledWidgetsContainer, { align: "center", direction: "row" },
                widgets.map((widget, index) => (React.createElement(Button, Object.assign({ disabled: disabled, tabIndex: -1, key: `widget_${index}` }, widget)))),
                drop));
        }
        return (React.createElement(Keyboard, { onDown: this.onKeyDown, onUp: this.onKeyUp },
            React.createElement(StyledDropInputContainer, null,
                React.createElement(ThemeContext.Consumer, null, theme => (React.createElement(StyledDropInput, Object.assign({ ref: this.inputRef, theme: theme, disabled: disabled, numWidgets: numWidgets, "aria-label": a11yTitle, defaultValue: defaultValue ? defaultValue.toString() : undefined }, rest)))),
                decorations)));
    }
}
DropInput.defaultProps = {
    dropAlign: { top: 'bottom', right: 'left' },
    dropIcon: React.createElement(FormDown, null),
    type: 'text',
    widgets: [],
};

const strCaretTrap = '[]';
const processCaretTraps = (mask) => {
    let indexOfCaretTrap;
    while (indexOfCaretTrap = mask.indexOf(strCaretTrap), indexOfCaretTrap !== -1) { // eslint-disable-line
        mask.splice(indexOfCaretTrap, 1);
    }
    return mask;
};
const transformMaskedValue = (value, providedMask, props) => {
    if (!providedMask) {
        return value.toString();
    }
    let { pipe } = props;
    let safeValue;
    if (value === undefined || value === null) {
        safeValue = '';
    }
    else {
        safeValue = value.toString();
    }
    let mask;
    if (typeof providedMask === 'object' &&
        providedMask.pipe !== undefined &&
        providedMask.mask !== undefined) {
        // eslint-disable-next-line no-param-reassign
        providedMask = providedMask.mask;
        ({ pipe } = providedMask);
    }
    if (typeof providedMask === 'function') {
        mask = providedMask(safeValue, Object.assign(Object.assign({}, props), { pipe }));
        // disable masking if `mask` is `false`
        if (mask === false) {
            return safeValue;
        }
        // The processed mask is what we're interested in
        mask = processCaretTraps(mask);
        // If the `providedMask` is not a function, we just use it as-is.
    }
    else {
        mask = providedMask;
    }
    let conformedValue = safeValue;
    const { guide, placeholderChar, placeholder, currentCaretPosition, showMask, keepCharPositions, } = props;
    const conformToMaskConfig = {
        previousPlaceholder: placeholder,
        guide,
        placeholderChar,
        pipe,
        currentCaretPosition,
        keepCharPositions,
    };
    const conformed = conformToMask(safeValue, mask, conformToMaskConfig);
    if (conformed) {
        ({ conformedValue } = conformed);
    }
    if (typeof pipe === 'function') {
        const pipeResults = pipe(conformedValue, Object.assign({ rawValue: safeValue }, conformToMaskConfig));
        if (typeof pipeResults === 'string') {
            conformedValue = pipeResults;
        }
    }
    if (conformedValue === placeholder) {
        conformedValue = showMask ? placeholder : '';
    }
    return conformedValue;
};

const maskedNumberValue = ({ value, prefix, suffix, thousandsSeparatorSymbol, }) => {
    let val;
    if (typeof value === 'string') {
        val = value.replace(new RegExp(`[${prefix}${suffix}${thousandsSeparatorSymbol}]`, 'g'), '');
        val = parseFloat(val);
        if (Number.isNaN(val)) {
            val = undefined;
        }
    }
    else {
        val = value;
    }
    return val;
};
const createMinMaxInputPipe = (_a) => {
    var { min, max, mask } = _a, props = __rest(_a, ["min", "max", "mask"]);
    return (conformedValue) => {
        if (typeof min === 'number' || typeof max === 'number') {
            const value = maskedNumberValue(Object.assign(Object.assign({}, props), { value: conformedValue }));
            if (typeof value === 'number') {
                if (typeof min === 'number' && value < min) {
                    const resolved = transformMaskedValue(min, mask, props);
                    if (resolved === undefined) {
                        return undefined;
                    }
                    return { value: resolved };
                }
                if (typeof max === 'number' && value > max) {
                    const resolved = transformMaskedValue(max, mask, props);
                    if (resolved === undefined) {
                        return undefined;
                    }
                    return { value: resolved };
                }
            }
        }
        return { value: conformedValue.toString() };
    };
};

/** A masked Input control with an optional drop button with the specified dropContent<br/>
 * `import { MakedInput } from 'grommet-controls';`<br/>
 * `<MakedInput mask={...} />`<br/>
 */
class MaskedInput extends Component {
    constructor() {
        super(...arguments);
        this.textMaskInputElement = null;
        this.inputControlRef = React.createRef();
        this.onInput = event => {
            const { onInput } = this.props;
            if (this.textMaskInputElement) {
                this.textMaskInputElement.update(event.target.value);
            }
            if (onInput) {
                onInput(event);
            }
        };
    }
    initTextMask() {
        const { props, props: { value }, } = this;
        if (props.mask && this.inputControlRef) {
            this.textMaskInputElement = createTextMaskInputElement(Object.assign({ 
                // eslint-disable-next-line react/no-find-dom-node
                inputElement: findDOMNode(this.inputControlRef.current).getElementsByTagName('input')[0] }, props));
            this.textMaskInputElement.update(value);
        }
    }
    componentDidMount() {
        this.initTextMask();
    }
    componentDidUpdate() {
        this.initTextMask();
    }
    maskedValue(value) {
        if (value === undefined) {
            return undefined;
        }
        const { mask } = this.props;
        if (value) {
            const conformed = transformMaskedValue(value, mask, this.props);
            return conformed;
        }
        return value;
    }
    render() {
        const _a = this.props, { defaultValue, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        value, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        mask, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        guide, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        showMask, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        pipe, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        placeholderChar, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        keepCharPositions } = _a, rest = __rest(_a, ["defaultValue", "value", "mask", "guide", "showMask", "pipe", "placeholderChar", "keepCharPositions"]);
        return (React.createElement(DropInput, Object.assign({ ref: this.inputControlRef, value: this.maskedValue(value), defaultValue: this.maskedValue(defaultValue), onInput: this.onInput }, rest)));
    }
}
MaskedInput.defaultProps = {
    type: 'text',
    guide: true,
    showMask: false,
    placeholderChar: '\u2000',
};
MaskedInput.alphabetic = /[A-Z]/i;
MaskedInput.placeholderChars = {
    whitespace: '\u2000',
    underscore: '_',
};
MaskedInput.digit = /\d/;
MaskedInput.createAutoCorrectedDatePipe = createAutoCorrectedDatePipe;
MaskedInput.emailMask = emailMask;
MaskedInput.createNumberMask = createNumberMask;
MaskedInput.createMinMaxInputPipe = createMinMaxInputPipe;
MaskedInput.maskedNumberValue = maskedNumberValue;

const sizeStyle = (props) => {
    const data = props.theme.calendar[props.size];
    return css `
    font-size: ${data.fontSize};
    line-height: ${data.lineHeight};
  `;
};
const StyledColors = styled.div `
  ${props => sizeStyle(props)}
`;
const StyledRows = styled.div `
  position: relative;
`;
const StyledRow = styled.div `
  position: relative;
  display: flex;
  flex-direction: row;
  flex-justify: between;
`;
const StyledColorContainer = styled.div `
  flex: 0 0;
`;
const colorSizeStyle = (props) => {
    const data = props.theme.calendar[props.size];
    return css `
    width: ${data.daySize};
    height: ${data.daySize};
  `;
};
const StyledColor = styled(Button) `
  top: 0;
  position: absolute;
  display: flex;
  justify-content: center;
  align-items: center;
  ${props => colorSizeStyle(props)}
  span {
    visibility: hidden;
  };  
  transition: transform .2s;
  &:hover {
    z-index: 10;
    width: auto;
    -webkit-transform:scale(2);
    -moz-transform:scale(2);
    transform:scale(2);
    span {
      visibility: visible;
    };
  );
`;

const buildState = (props) => {
    const { colors, color, columns, wrap } = props;
    let colorRows = [];
    let lastRow = null;
    if (colors) {
        Object.keys(colors).forEach(item => {
            if (typeof colors[item] === 'object') {
                const row = { name: item, colors: [], buttonRef: React.createRef() };
                Object.keys(colors[item]).forEach(colorName => {
                    const colorsColor = colors[item][colorName];
                    row.colors.push({ name: colorName, color: colorsColor });
                });
                colorRows.push(row);
            }
            else {
                if (!lastRow) {
                    lastRow = { name: undefined, colors: [] };
                    colorRows.push(lastRow);
                }
                lastRow.colors.push({
                    name: item,
                    color: colors[item],
                    buttonRef: React.createRef(),
                });
            }
        });
    }
    const colorsPerRow = columns ||
        (colorRows.length === 1
            ? Math.sqrt(colorRows[0].colors.length)
            : colorRows.reduce((res, row) => Math.min(res, row.colors.length), Number.MAX_SAFE_INTEGER));
    let wrapColors = wrap;
    if (wrapColors === undefined) {
        wrapColors = columns === undefined && colorRows.length === 1;
    }
    if (wrapColors) {
        const finalRows = [];
        colorRows.forEach(row => {
            while (row.colors.length > 0) {
                finalRows.push({
                    name: row.name,
                    colors: row.colors.splice(0, colorsPerRow),
                });
            }
        });
        colorRows = finalRows;
    }
    else {
        colorRows = colorRows.map(row => (Object.assign(Object.assign({}, row), { colors: row.colors.filter((_, index) => index < colorsPerRow) })));
    }
    let activeRow = 0;
    let activeColor = 0;
    colorRows.find((row, rowIndex) => row.colors.find((item, colorIndex) => {
        const found = item.color === color;
        if (found) {
            activeRow = rowIndex;
            activeColor = colorIndex;
        }
        return found;
    }));
    return { colorRows, activeRow, activeColor };
};
/** A color selection element, with custom color palettes.<br/>
 *`import { Colors } from 'grommet-controls';`<br/>
 *`<Colors colors={...} />`<br/>
 */
class Colors extends Component {
    constructor(props) {
        super(props);
        this.setFocus = false;
        this.timer = 0;
        this.setActive = ({ rowIndex, colorIndex }) => {
            const { colorRows } = this.state;
            this.setFocus = true;
            const activeRow = Math.min(Math.max(0, rowIndex), colorRows.length - 1);
            const color = Math.max(0, colorIndex);
            const activeColor = Math.min(color, colorRows[activeRow].colors.length - 1);
            this.setState({
                activeRow,
                activeColor,
            });
        };
        this.onClickColor = ({ color, rowIndex, colorIndex, rowName, colorName, }) => () => {
            const { onSelect } = this.props;
            this.setActive({ rowIndex, colorIndex });
            if (onSelect) {
                onSelect({ color, rowName, colorName });
            }
        };
        this.state = buildState(props);
    }
    static getDerivedStateFromProps(nextProps) {
        return buildState(nextProps);
    }
    componentDidUpdate() {
        if (this.setFocus) {
            const { activeRow, activeColor, colorRows } = this.state;
            this.setFocus = false;
            if (colorRows[activeRow] &&
                colorRows[activeRow].colors[activeColor] &&
                colorRows[activeRow].colors[activeColor].buttonRef) {
                // eslint-disable-next-line react/no-find-dom-node
                const buttonNode = findDOMNode(colorRows[activeRow].colors[activeColor].buttonRef.current);
                if (buttonNode) {
                    buttonNode.scrollIntoView();
                    buttonNode.focus();
                }
            }
        }
    }
    componentWillUnmount() {
        clearTimeout(this.timer);
    }
    render() {
        const _a = this.props, { 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        wrap, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onSelect, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        columns, size } = _a, rest = __rest(_a, ["wrap", "onSelect", "columns", "size"]);
        const { colorRows, activeRow, activeColor } = this.state;
        const colors = (theme, cellSize) => colorRows.map((row, rowIndex) => (React.createElement(StyledRow, { key: `row_${rowIndex}`, theme: theme, style: {
                width: `${cellSize * row.colors.length}px`,
                height: `${cellSize}px`,
            } }, row.colors.map((color, colorIndex) => {
            const isActive = activeRow === rowIndex && activeColor === colorIndex;
            const colorStyle = {
                backgroundColor: color.color,
                color: normalizeColor('text', theme),
                left: `${cellSize * colorIndex}px`,
            };
            return (React.createElement(StyledColorContainer, { key: `color_${colorIndex}`, theme: theme },
                React.createElement(StyledColor
                // eslint-disable-next-line no-param-reassign
                , { 
                    // eslint-disable-next-line no-param-reassign
                    ref: color.buttonRef, style: colorStyle, size: size, theme: theme, tabIndex: isActive ? 0 : -1, a11yTitle: `${row.name !== undefined ? row.name : ''} ${color.name}`, plain: true, active: isActive, hoverIndicator: "background", onClick: this.onClickColor({
                        color: color.color,
                        rowIndex,
                        colorIndex,
                        colorName: color.name,
                        rowName: row.name,
                    }) },
                    React.createElement("span", null, color.color))));
        }))));
        return (React.createElement(ThemeContext.Consumer, null, theme => {
            const cellSize = parseMetricToNum(theme.calendar[size].daySize);
            return (React.createElement(StyledColors, Object.assign({ size: size, theme: theme }, rest),
                React.createElement(Keyboard, { onUp: event => {
                        event.preventDefault();
                        this.setActive({
                            rowIndex: activeRow - 1,
                            colorIndex: activeColor,
                        });
                    }, onDown: event => {
                        event.preventDefault();
                        this.setActive({
                            rowIndex: activeRow + 1,
                            colorIndex: activeColor,
                        });
                    }, onLeft: () => this.setActive({
                        rowIndex: activeRow,
                        colorIndex: activeColor - 1,
                    }), onRight: () => this.setActive({
                        rowIndex: activeRow,
                        colorIndex: activeColor + 1,
                    }) },
                    React.createElement(Box, null,
                        React.createElement(StyledRows, { style: { height: `${cellSize * colorRows.length}px` } }, colors(theme, cellSize))))));
        }));
    }
}
Colors.defaultProps = {
    size: 'medium',
};

const StyledColorButton = styled.span `
  display: inline-flex;
  svg {
    border: ${props => `${props.theme.button.border.width} solid ${props.theme.global.colors.border}`};
    fill: ${props => props.selectedColor};
    stroke: ${props => props.selectedColor};
    transition: none;
  }
`;
/** A masked color entry field, with a drop button to select a color<br/>
 * All properties of MaskedInput apply<br/>
 * `import { ColorInput } from 'grommet-controls';`<br/>
 * `<ColorInput colors={...} value={...} />`<br/>
 */
class ColorInput extends Component {
    constructor(props) {
        super(props);
        this.upDateValue = null;
        this.onChange = e => {
            const { onChange } = this.props;
            this.setState({ selectedColor: e.target.value });
            if (onChange) {
                onChange(e);
            }
        };
        this.onSelect = ({ color }) => {
            this.setState({ selectedColor: color });
            this.upDateValue(color);
        };
        this.state = {
            selectedColor: (props.value || props.defaultValue),
        };
    }
    static getDerivedStateFromProps(nextProps) {
        return {
            selectedColor: nextProps.value,
        };
    }
    render() {
        const _a = this.props, { columns, wrap, colors, size } = _a, rest = __rest(_a, ["columns", "wrap", "colors", "size"]);
        const { selectedColor } = this.state;
        return (React.createElement(ThemeContext.Consumer, null, theme => (React.createElement(MaskedInput, Object.assign({ update: update => {
                this.upDateValue = update;
            }, dropIcon: React.createElement(StyledColorButton, { theme: theme, selectedColor: selectedColor },
                React.createElement(StopFill, null)), dropContent: React.createElement(Colors, { color: selectedColor, colors: colors, onSelect: this.onSelect, columns: columns, wrap: wrap, size: size }), onChange: this.onChange }, rest)))));
    }
}
ColorInput.defaultProps = {
    size: 'small',
    mask: [
        '#',
        /[0-9a-fA-F]/,
        /[0-9a-fA-F]/,
        /[0-9a-fA-F]/,
        /[0-9a-fA-F]/,
        /[0-9a-fA-F]/,
        /[0-9a-fA-F]/,
    ],
};

/**
 * A Color selection field with form validation<br/>
 */
const ColorInputField = (props) => (React.createElement(WithFormField, Object.assign({}, props), childProps => React.createElement(ColorInput, Object.assign({}, childProps))));

const smallDate = (date, locale = 'en-us') => new Date(date).toLocaleDateString(locale, {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
});
const shortDate = (date, locale = 'en-us') => new Date(date).toLocaleDateString(locale, {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
});
const longDate = (date, locale = 'en-us') => new Date(date).toLocaleDateString(locale, {
    weekday: 'short',
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
});

/**
 * A masked date entry field with a drop down calendar<br/>
 * All properties of MaskedInput apply<br/>
 * `import { DateInput } from 'grommet-controls';`<br/>
 * `<DateInput value={...} />`<br/>
 */
class DateInput extends Component {
    constructor() {
        super(...arguments);
        this.upDateValue = null;
        this.onSelect = isoDate => {
            const date = new Date(isoDate);
            this.upDateValue(smallDate(date));
        };
    }
    render() {
        const _a = this.props, { value, bounds, dates, disabledDates, autocorrect, firstDayOfWeek, locale, size, mask: userMask, maskFormat } = _a, rest = __rest(_a, ["value", "bounds", "dates", "disabledDates", "autocorrect", "firstDayOfWeek", "locale", "size", "mask", "maskFormat"]);
        let mask;
        if (userMask) {
            mask = { mask: userMask };
        }
        else if (autocorrect) {
            mask = {
                mask: [/\d/, /\d/, '/', /\d/, /\d/, '/', /\d/, /\d/, /\d/, /\d/],
                pipe: MaskedInput.createAutoCorrectedDatePipe(maskFormat),
                keepCharPositions: true,
            };
        }
        else {
            mask = {
                mask: [/\d/, /\d/, '/', /\d/, /\d/, '/', /\d/, /\d/, /\d/, /\d/],
            };
        }
        const controlledValue = value === undefined ? '' : value;
        return (React.createElement(MaskedInput, Object.assign({ update: update => {
                this.upDateValue = update;
            }, value: controlledValue, dropContent: React.createElement(Box, { pad: "small" },
                React.createElement(Calendar, { date: controlledValue.toString(), onSelect: this.onSelect, bounds: bounds, dates: dates, disabled: disabledDates, firstDayOfWeek: firstDayOfWeek, locale: locale, size: size })) }, Object.assign(Object.assign({}, rest), mask))));
    }
}
DateInput.defaultProps = {
    dropIcon: React.createElement(Calendar$1, null),
    size: 'small',
    a11yDropTitle: 'Open calendar',
};

/**
 * A Date input field with form validation<br/>
 */
const DateInputField = (props) => (React.createElement(WithFormField, Object.assign({}, props), childProps => React.createElement(DateInput, Object.assign({}, childProps))));

/**
 * A masked input with a default mask for handling email addresses<br/>
 * All properties of MaskedInput apply<br/>
 * `import { EmailInput } from 'grommet-controls';`<br/>
 * `<EmailInput value={...} />`<br/>
 */
const EmailInput = (props) => (React.createElement(MaskedInput, Object.assign({ mask: MaskedInput.emailMask, inputMode: "email" }, props)));

/**
 * An email input field with form validation<br/>
 */
const EmailInputField = (props) => (React.createElement(WithFormField, Object.assign({}, props), childProps => React.createElement(EmailInput, Object.assign({}, childProps))));

const StyledHeader = styled(Box) `
  position: ${props => props.position};
  ${props => {
    if (props.position === 'fixed' ||
        props.position === 'absolute' ||
        props.position === 'sticky') {
        return `
        top: 0;
        left: auto;
        right: 0;  
        z-index: ${props.zIndex};
      `;
    }
    return undefined;
}}
`;

/**
 * A page header component
 * ```$ npm install grommet-controls
 * import { Header } from 'grommet-controls';
 * <Header>
 *   ...
 * </Header>
 * ```
 */
const Header = (_a) => {
    var { children } = _a, rest = __rest(_a, ["children"]);
    return (React.createElement(StyledHeader, Object.assign({ tag: "header" }, rest), children));
};
Header.defaultProps = {
    position: 'relative',
    zIndex: 10,
    direction: 'row',
    background: 'brand',
    fill: 'horizontal',
    justify: 'between',
    align: 'center',
    elevation: 'medium',
    pad: 'medium',
};

var StyledIconButton = styled(Button) `
  border-radius: 50%;
`;

/** A Button with a hover effect, all properties of Button apply<br />
 * `import { IconButton } from 'grommet-controls';`<br />
 * `<IconButton icon='...' />`<br />
 */
const IconButton = (props) => (React.createElement(StyledIconButton, Object.assign({}, props, { hoverIndicator: {
        dark: 'dark-2',
        light: 'light-2',
    } })));

/**
 * A masked input field with form validation<br/>
 */
const MaskedInputField = (props) => (React.createElement(WithFormField, Object.assign({}, props), childProps => React.createElement(MaskedInput, Object.assign({}, childProps))));

const pink = {
    '50': '#fce4ec',
    '100': '#f8bbd0',
    '200': '#f48fb1',
    '300': '#f06292',
    '400': '#ec407a',
    '500': '#e91e63',
    '600': '#d81b60',
    '700': '#c2185b',
    '800': '#ad1457',
    '900': '#880e4f',
    a100: '#ff80ab',
    a200: '#ff4081',
    a400: '#f50057',
    a700: '#c51162',
};
const purple$1 = {
    '50': '#f3e5f5',
    '100': '#e1bee7',
    '200': '#ce93d8',
    '300': '#ba68c8',
    '400': '#ab47bc',
    '500': '#9c27b0',
    '600': '#8e24aa',
    '700': '#7b1fa2',
    '800': '#6a1b9a',
    '900': '#4a148c',
    a100: '#ea80fc',
    a200: '#e040fb',
    a400: '#d500f9',
    a700: '#aa00ff',
};
const deepPurple = {
    '50': '#ede7f6',
    '100': '#d1c4e9',
    '200': '#b39ddb',
    '300': '#9575cd',
    '400': '#7e57c2',
    '500': '#673ab7',
    '600': '#5e35b1',
    '700': '#512da8',
    '800': '#4527a0',
    '900': '#311b92',
    a100: '#b388ff',
    a200: '#7c4dff',
    a400: '#651fff',
    a700: '#6200ea',
};
const indigo = {
    '50': '#e8eaf6',
    '100': '#c5cae9',
    '200': '#9fa8da',
    '300': '#7986cb',
    '400': '#5c6bc0',
    '500': '#3f51b5',
    '600': '#3949ab',
    '700': '#303f9f',
    '800': '#283593',
    '900': '#1a237e',
    a100: '#8c9eff',
    a200: '#536dfe',
    a400: '#3d5afe',
    a700: '#304ffe',
};
const blue$1 = {
    '50': '#e3f2fd',
    '100': '#bbdefb',
    '200': '#90caf9',
    '300': '#64b5f6',
    '400': '#42a5f5',
    '500': '#2196f3',
    '600': '#1e88e5',
    '700': '#1976d2',
    '800': '#1565c0',
    '900': '#0d47a1',
    a100: '#82b1ff',
    a200: '#448aff',
    a400: '#2979ff',
    a700: '#2962ff',
};
const lightBlue = {
    '50': '#e1f5fe',
    '100': '#b3e5fc',
    '200': '#81d4fa',
    '300': '#4fc3f7',
    '400': '#29b6f6',
    '500': '#03a9f4',
    '600': '#039be5',
    '700': '#0288d1',
    '800': '#0277bd',
    '900': '#01579b',
    a100: '#80d8ff',
    a200: '#40c4ff',
    a400: '#00b0ff',
    a700: '#0091ea',
};
const cyan = {
    '50': '#e0f7fa',
    '100': '#b2ebf2',
    '200': '#80deea',
    '300': '#4dd0e1',
    '400': '#26c6da',
    '500': '#00bcd4',
    '600': '#00acc1',
    '700': '#0097a7',
    '800': '#00838f',
    '900': '#006064',
    a100: '#84ffff',
    a200: '#18ffff',
    a400: '#00e5ff',
    a700: '#00b8d4',
};
const teal$1 = {
    '50': '#e0f2f1',
    '100': '#b2dfdb',
    '200': '#80cbc4',
    '300': '#4db6ac',
    '400': '#26a69a',
    '500': '#009688',
    '600': '#00897b',
    '700': '#00796b',
    '800': '#00695c',
    '900': '#004d40',
    a100: '#a7ffeb',
    a200: '#64ffda',
    a400: '#1de9b6',
    a700: '#00bfa5',
};
const green$1 = {
    '50': '#e8f5e9',
    '100': '#c8e6c9',
    '200': '#a5d6a7',
    '300': '#81c784',
    '400': '#66bb6a',
    '500': '#4caf50',
    '600': '#43a047',
    '700': '#388e3c',
    '800': '#2e7d32',
    '900': '#1b5e20',
    a100: '#b9f6ca',
    a200: '#69f0ae',
    a400: '#00e676',
    a700: '#00c853',
};
const lightGreen = {
    '50': '#f1f8e9',
    '100': '#dcedc8',
    '200': '#c5e1a5',
    '300': '#aed581',
    '400': '#9ccc65',
    '500': '#8bc34a',
    '600': '#7cb342',
    '700': '#689f38',
    '800': '#558b2f',
    '900': '#33691e',
    a100: '#ccff90',
    a200: '#b2ff59',
    a400: '#76ff03',
    a700: '#64dd17',
};
const lime$1 = {
    '50': '#f9fbe7',
    '100': '#f0f4c3',
    '200': '#e6ee9c',
    '300': '#dce775',
    '400': '#d4e157',
    '500': '#cddc39',
    '600': '#c0ca33',
    '700': '#afb42b',
    '800': '#9e9d24',
    '900': '#827717',
    a100: '#f4ff81',
    a200: '#eeff41',
    a400: '#c6ff00',
    a700: '#aeea00',
};
const yellow$1 = {
    '50': '#fffde7',
    '100': '#fff9c4',
    '200': '#fff59d',
    '300': '#fff176',
    '400': '#ffee58',
    '500': '#ffeb3b',
    '600': '#fdd835',
    '700': '#fbc02d',
    '800': '#f9a825',
    '900': '#f57f17',
    a100: '#ffff8d',
    a200: '#ffff00',
    a400: '#ffea00',
    a700: '#ffd600',
};
const amber = {
    '50': '#fff8e1',
    '100': '#ffecb3',
    '200': '#ffe082',
    '300': '#ffd54f',
    '400': '#ffca28',
    '500': '#ffc107',
    '600': '#ffb300',
    '700': '#ffa000',
    '800': '#ff8f00',
    '900': '#ff6f00',
    a100: '#ffe57f',
    a200: '#ffd740',
    a400: '#ffc400',
    a700: '#ffab00',
};
const orange = {
    '50': '#fff3e0',
    '100': '#ffe0b2',
    '200': '#ffcc80',
    '300': '#ffb74d',
    '400': '#ffa726',
    '500': '#ff9800',
    '600': '#fb8c00',
    '700': '#f57c00',
    '800': '#ef6c00',
    '900': '#e65100',
    a100: '#ffd180',
    a200: '#ffab40',
    a400: '#ff9100',
    a700: '#ff6d00',
};
const deepOrange = {
    '50': '#fbe9e7',
    '100': '#ffccbc',
    '200': '#ffab91',
    '300': '#ff8a65',
    '400': '#ff7043',
    '500': '#ff5722',
    '600': '#f4511e',
    '700': '#e64a19',
    '800': '#d84315',
    '900': '#bf360c',
    a100: '#ff9e80',
    a200: '#ff6e40',
    a400: '#ff3d00',
    a700: '#dd2c00',
};
const brown = {
    '50': '#efebe9',
    '100': '#d7ccc8',
    '200': '#bcaaa4',
    '300': '#a1887f',
    '400': '#8d6e63',
    '500': '#795548',
    '600': '#6d4c41',
    '700': '#5d4037',
    '800': '#4e342e',
    '900': '#3e2723',
};
const grey = {
    '50': '#fafafa',
    '100': '#f5f5f5',
    '200': '#eeeeee',
    '300': '#e0e0e0',
    '400': '#bdbdbd',
    '500': '#9e9e9e',
    '600': '#757575',
    '700': '#616161',
    '800': '#424242',
    '900': '#212121',
};
const blueGrey = {
    '50': '#eceff1',
    '100': '#cfd8dc',
    '200': '#b0bec5',
    '300': '#90a4ae',
    '400': '#78909c',
    '500': '#607d8b',
    '600': '#546e7a',
    '700': '#455a64',
    '800': '#37474f',
    '900': '#263238',
};
const materialColors = {
    amber,
    blue: blue$1,
    blueGrey,
    brown,
    cyan,
    deepOrange,
    deepPurple,
    green: green$1,
    grey,
    indigo,
    lightBlue,
    lightGreen,
    lime: lime$1,
    orange,
    pink,
    purple: purple$1,
    teal: teal$1,
    yellow: yellow$1,
};

const StatusIcons = {
    ok: StatusGood,
    warning: StatusWarning,
    error: StatusCritical,
    unknown: StatusUnknown,
    disabled: StatusDisabled,
    info: StatusInfo,
};
const SIZE_LEVELS = {
    small: {
        level: 4,
        size: 'xsmall',
        meterSize: 'xsmall',
    },
    medium: {
        level: 3,
        size: 'small',
        meterSize: 'small',
    },
    large: {
        level: 1,
        size: 'medium',
        meterSize: 'large',
    },
};
/**
 * A Box to display notification messages<br/>
 * `import { Notification } from 'grommet-controls';`<br/>
 * `<Notification message={...} onClose={...} />`<br/>
 */
const Notification = (_a) => {
    var { status, message, locale, closer, margin, reverse, a11yTitle, background, border, timestamp, icon, strong, round, pad, size, state, onClose, percentComplete } = _a, rest = __rest(_a, ["status", "message", "locale", "closer", "margin", "reverse", "a11yTitle", "background", "border", "timestamp", "icon", "strong", "round", "pad", "size", "state", "onClose", "percentComplete"]);
    const sizeLevel = SIZE_LEVELS[size];
    let closeBtn;
    if (onClose) {
        const closeIcon = closer || React.createElement(Close, { size: sizeLevel.size });
        closeBtn = (React.createElement(Box, { pad: pad },
            React.createElement(Button, { a11yTitle: a11yTitle, onClick: onClose }, closeIcon)));
    }
    let heading = message;
    if (strong) {
        heading = React.createElement("strong", null, heading);
    }
    let statusIcon;
    if (icon) {
        const StatusIcon = StatusIcons[status];
        statusIcon = React.isValidElement(icon) ? (icon) : (React.createElement(StatusIcon, { size: sizeLevel.size }));
    }
    let progress;
    if (percentComplete || percentComplete === 0) {
        progress = (React.createElement(Box, { direction: "row", align: "center", gap: "medium", style: { whiteSpace: 'nowrap' } },
            React.createElement(Meter, { size: sizeLevel.meterSize, thickness: "small", values: [
                    {
                        label: percentComplete.toFixed(0),
                        value: percentComplete,
                        color: 'accent-1',
                    },
                ] }),
            React.createElement(Text, { size: "small" }, ` ${percentComplete} %`)));
    }
    let timeStamp;
    if (timestamp) {
        timeStamp = longDate(timestamp, locale);
    }
    let first;
    let second;
    if (reverse) {
        first = heading;
        second = statusIcon;
    }
    else {
        first = statusIcon;
        second = heading;
    }
    const content = (React.createElement(Box, { flex: "grow", pad: pad },
        React.createElement(Heading, { level: sizeLevel.level, margin: margin, style: { maxWidth: '100%' } },
            React.createElement(Box, { direction: "row", align: "center", gap: "small" },
                first,
                second)),
        React.createElement(Text, { size: sizeLevel.size }, state),
        React.createElement(Text, { size: sizeLevel.size }, timeStamp),
        progress));
    if (reverse) {
        first = closeBtn;
        second = content;
    }
    else {
        first = content;
        second = closeBtn;
    }
    return (React.createElement(Box, Object.assign({ direction: reverse ? 'row-reverse' : 'row', fill: "horizontal", border: border, round: round, role: "checkbox", "aria-checked": true, background: background || `status-${status}` }, rest),
        first,
        second));
};
Notification.defaultProps = {
    status: 'info',
    size: 'medium',
    message: 'Notification...',
    icon: true,
    animation: 'fadeIn',
    closer: undefined,
    pad: 'small',
    margin: 'small',
    locale: 'en-us',
};

const precision = n => {
    // eslint-disable-next-line no-restricted-globals
    if (!isFinite(n))
        return 0;
    let e = 1;
    let p = 0;
    while (Math.round(n * e) / e !== n) {
        e *= 10;
        p += 1;
    }
    return p;
};
const minMax = ({ value, min, max }) => {
    let val = value;
    if (min !== undefined) {
        val = Math.max(val, min);
    }
    if (max !== undefined) {
        val = Math.min(val, max);
    }
    return val;
};
/** A masked number input, with widgets to increment/decrement the value<br/>
 *  Additionally, all properties of MaskedInput apply<br/>
 *  `import { NumberInput } from 'grommet-controls';`<br/>
 *  `<NumberInput value={...} />`<br/>
 */
class NumberInput extends Component {
    constructor() {
        super(...arguments);
        this.upDateValue = null;
        this.value = undefined;
        this.valueToNumber = (value) => {
            const { prefix, suffix, thousandsSeparatorSymbol, decimalSymbol, } = this.props;
            return MaskedInput.maskedNumberValue({
                value,
                prefix,
                suffix,
                thousandsSeparatorSymbol,
                decimalSymbol,
            });
        };
        this.isFloat = (val) => {
            const floatRegex = /^-?\d+(?:[.,]\d*?)?$/;
            if (!floatRegex.test(val.toString())) {
                return false;
            }
            // eslint-disable-next-line no-restricted-globals
            if (isNaN(parseFloat(val.toString()))) {
                return false;
            }
            return true;
        };
        this.addStep = () => {
            const { max, min, step, value } = this.props;
            let val = this.isFloat(value)
                ? (this.valueToNumber(value) + step).toFixed(precision(step))
                : min || 0;
            if (typeof val === 'number' && Number.isNaN(val)) {
                if (min !== undefined) {
                    val = min;
                }
                else {
                    val = undefined;
                }
            }
            else {
                val = minMax({ value: val, min, max });
            }
            this.upDateValue(val.toString());
        };
        this.subtractStep = () => {
            const { max, min, step, value } = this.props;
            let val = this.isFloat(value)
                ? (this.valueToNumber(value) - step).toFixed(precision(step))
                : max || 0;
            if (typeof val === 'number' && Number.isNaN(val)) {
                if (max !== undefined) {
                    val = max;
                }
                else {
                    val = undefined;
                }
            }
            else {
                val = minMax({ value: val, min, max });
            }
            this.upDateValue(val.toString());
        };
        this.onChange = e => {
            const { onChange, emptyValue } = this.props;
            if (onChange) {
                let { value } = e.target;
                if (this.value !== value) {
                    if (value === undefined) {
                        value = emptyValue;
                    }
                    this.value = value;
                    onChange(Object.assign(Object.assign({}, e), { target: Object.assign(Object.assign({}, e.target), { value }) }));
                }
            }
        };
    }
    render() {
        const _a = this.props, { 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        onChange, min, max, step, pipe: userPipe, prefix, suffix, thousandsSeparatorSymbol, decimalSymbol, decimals, integers, a11yIncrement, a11yDecrement, mask: userMask, addIcon, subtractIcon, disabled } = _a, rest = __rest(_a, ["onChange", "min", "max", "step", "pipe", "prefix", "suffix", "thousandsSeparatorSymbol", "decimalSymbol", "decimals", "integers", "a11yIncrement", "a11yDecrement", "mask", "addIcon", "subtractIcon", "disabled"]);
        const allowNegative = typeof min !== 'number' || min < 0;
        const includeThousandsSeparator = !!thousandsSeparatorSymbol;
        const allowDecimal = decimals === null || (typeof decimals === 'number' && decimals > 0);
        const mask = userMask ||
            MaskedInput.createNumberMask({
                prefix,
                suffix,
                includeThousandsSeparator,
                thousandsSeparatorSymbol,
                allowDecimal,
                decimalSymbol,
                decimalLimit: decimals,
                integerLimit: integers,
                allowNegative,
            });
        const pipe = userPipe ||
            MaskedInput.createMinMaxInputPipe(Object.assign({ mask,
                prefix,
                suffix,
                thousandsSeparatorSymbol,
                decimalSymbol,
                min,
                max }, rest));
        return (React.createElement(MaskedInput, Object.assign({ update: update => {
                this.upDateValue = update;
            }, pattern: "[0-9]*", inputMode: "numeric", onKeyDown: this.subtractStep, onKeyUp: this.addStep, disabled: disabled, onChange: this.onChange, pipe: pipe, mask: mask, widgets: [
                {
                    icon: addIcon,
                    onClick: disabled ? undefined : this.addStep,
                    'aria-label': `${a11yIncrement} ${step}`,
                },
                {
                    icon: subtractIcon,
                    onClick: disabled ? undefined : this.subtractStep,
                    'aria-label': `${a11yDecrement} ${step}`,
                },
            ] }, rest)));
    }
}
NumberInput.defaultProps = {
    emptyValue: '',
    step: 1,
    addIcon: React.createElement(Add, null),
    subtractIcon: React.createElement(Subtract, null),
    prefix: '',
    suffix: '',
    thousandsSeparatorSymbol: '',
    decimalSymbol: '.',
    decimals: null,
    integers: null,
    a11yIncrement: 'Increment by',
    a11yDecrement: 'Decrement by',
};

/**
 * A numeric input field with form validation<br/>
 */
const NumberInputField = (props) => (React.createElement(WithFormField, Object.assign({}, props), childProps => React.createElement(NumberInput, Object.assign({}, childProps))));

/**
 *A password field with show/hide password toggle<br/>
 *All properties of DropInput apply<br/>
 *`import { PasswordInput } from 'grommet-controls';`<br/>
 *`<PasswordInput value={...} />`<br/>
 */
class PasswordInput extends Component {
    constructor() {
        super(...arguments);
        this.state = { showPassword: false };
        this.toggleView = e => {
            const { showPassword } = this.state;
            e.stopPropagation();
            this.setState({ showPassword: !showPassword });
        };
    }
    render() {
        const _a = this.props, { viewIcon, hideIcon, a11yViewPassword, a11yHidePassword } = _a, rest = __rest(_a, ["viewIcon", "hideIcon", "a11yViewPassword", "a11yHidePassword"]);
        const { showPassword } = this.state;
        return (React.createElement(DropInput, Object.assign({ type: showPassword ? 'text' : 'password', widgets: [
                {
                    icon: showPassword ? hideIcon : viewIcon,
                    'aria-label': showPassword ? a11yHidePassword : a11yViewPassword,
                    onClick: this.toggleView,
                },
            ] }, rest)));
    }
}
PasswordInput.defaultProps = {
    viewIcon: React.createElement(FormView, null),
    hideIcon: React.createElement(Hide, null),
    a11yViewPassword: 'View password',
    a11yHidePassword: 'Hide password',
};

/**
 * A password input field with form validation<br/>
 */
const PasswordInputField = (props) => (React.createElement(WithFormField, Object.assign({}, props), childProps => React.createElement(PasswordInput, Object.assign({}, childProps))));

/* eslint-disable no-param-reassign,no-nested-ternary */
//
// ########################################################################
// Non-exported Helpers
// ########################################################################
function isArray(a) {
    return Array.isArray(a);
}
function flattenDeep(arr, newArr = []) {
    if (!isArray(arr)) {
        newArr.push(arr);
    }
    else {
        for (let i = 0; i < arr.length; i += 1) {
            flattenDeep(arr[i], newArr);
        }
    }
    return newArr;
}
function makePathArray(obj) {
    return flattenDeep(obj)
        .join('.')
        .replace(/\[/g, '.')
        .replace(/]/g, '')
        .split('.');
}
function get(obj, path, def) {
    if (!path) {
        return obj;
    }
    const pathObj = makePathArray(path);
    let val;
    try {
        val = pathObj.reduce((current, pathPart) => current[pathPart], obj);
    }
    catch (e) {
        // continue regardless of error
    }
    return typeof val !== 'undefined' ? val : def;
}
function set(obj = {}, path, value) {
    const keys = makePathArray(path);
    let keyPart;
    let cursor = obj;
    // eslint-disable-next-line no-cond-assign
    while ((keyPart = keys.shift()) && keys.length) {
        if (!cursor[keyPart]) {
            cursor[keyPart] = {};
        }
        cursor = cursor[keyPart];
    }
    cursor[keyPart] = value;
    return obj;
}
function range(n) {
    const arr = [];
    for (let i = 0; i < n; i += 1) {
        arr.push(n);
    }
    return arr;
}
function orderBy(arr, funcs, dirs, indexKey) {
    return arr.sort((rowA, rowB) => {
        for (let i = 0; i < funcs.length; i += 1) {
            const comp = funcs[i];
            const desc = dirs[i] === false || dirs[i] === 'desc';
            const sortInt = comp(rowA, rowB);
            if (sortInt) {
                return desc ? -sortInt : sortInt;
            }
        }
        // Use the row index for tie breakers
        return dirs[0]
            ? rowA[indexKey] - rowB[indexKey]
            : rowB[indexKey] - rowA[indexKey];
    });
}
function remove(a, b) {
    return a.filter((o, i) => {
        const r = b(o);
        if (r) {
            a.splice(i, 1);
            return true;
        }
        return false;
    });
}
function clone(a) {
    try {
        return JSON.parse(JSON.stringify(a, (_, value) => {
            if (typeof value === 'function') {
                return value.toString();
            }
            return value;
        }));
    }
    catch (e) {
        return a;
    }
}
function getFirstDefined(...args) {
    for (let i = 0; i < args.length; i += 1) {
        if (typeof args[i] !== 'undefined') {
            return args[i];
        }
    }
    return undefined;
}
function sum(arr) {
    return arr.reduce((a, b) => a + b, 0);
}
function groupBy(xs, key) {
    return xs.reduce((rv, x, i) => {
        const resKey = typeof key === 'function' ? key(x, i) : x[key];
        rv[resKey] = isArray(rv[resKey]) ? rv[resKey] : [];
        rv[resKey].push(x);
        return rv;
    }, {});
}
function asPx(value) {
    value = Number(value);
    return Number.isNaN(value) ? null : `${value}px`;
}
function compactObject(obj) {
    const newObj = {};
    if (obj) {
        Object.keys(obj).map(key => {
            if (Object.prototype.hasOwnProperty.call(obj, key) &&
                obj[key] !== undefined &&
                typeof obj[key] !== 'undefined') {
                newObj[key] = obj[key];
            }
            return true;
        });
    }
    return newObj;
}
function isSortingDesc(d) {
    return !!(d.sort === 'desc' || d.desc === true || d.asc === false);
}
function normalizeComponent(Comp, params = {}, fallback = Comp) {
    return typeof Comp === 'function' ? (Object.getPrototypeOf(Comp).isReactComponent ? (React.createElement(Comp, Object.assign({}, params))) : (Comp(params))) : (fallback);
}
var _ = {
    get,
    set,
    orderBy,
    range,
    remove,
    clone,
    getFirstDefined,
    sum,
    groupBy,
    isArray,
    compactObject,
    isSortingDesc,
    normalizeComponent,
    asPx,
};

const StyledTableComponent = styled(Box) `
  align-items: stretch;
  width: 100%;
  border-collapse: collapse;
  overflow: auto;
`;
const StyledTableBodyComponent = styled(Box) ``;
const StyledTHeadComponent = styled(Box) `
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
`;
const StyledResizerComponent = styled(Box) `
  display: inline-block;
  position: absolute;
  width: 36px;
  top: 0;
  bottom: 0;
  right: -18px;
  cursor: col-resize;
  z-index: 10;
`;
const StyledThComponent = styled(Box) `
  position: relative;
  ${props => props.sortable &&
    `
    cursor: pointer;
  `}    
  ${props => props.hidden &&
    `
    width: 0 !important;
    min-width: 0 !important;
    padding: 0 !important;
    border: 0 !important;
    opacity: 0 !important;
  `}
  ${props => props.pivot &&
    `
    &:after,:before {
      left: 100%;
      top: 50%;
      border: solid transparent;
      content: " ";
      height: 0;
      width: 0;
      position: absolute;
      pointer-events: none
    }
  
    &:after {
      border-color: rgba(255, 255, 255, 0);
      border-left-color: #fff;
      border-width: 8px;
      margin-top: -8px
    }
  
    &:before {
      border-color: rgba(102, 102, 102, 0);
      border-left-color: #f7f7f7;
      border-width: 10px;
      margin-top: -10px
    }

  `}  
  ${props => props.resizable &&
    `
    overflow: visible;

    &:last-child {
      overflow: hidden
    }
  `}  
`;
const StyledTrGroupComponent = styled(Box) `
  align-items: stretch;
`;
const StyledTrComponent = styled(Box) `
  ${props => props.hover &&
    `
    &:hover {
      background-color: ${normalizeColor(props.hover.background || props.theme.global.hover.background, props.theme)};
      color: ${normalizeColor(props.hover.color || props.theme.global.hover.color, props.theme)};
    }  
  `}
`;
const StyledTdComponent = styled(Box) `
  text-overflow: ellipsis;
  overflow: hidden;
  display: block;
  white-space: nowrap;
  ${props => props.hidden &&
    `
    width: 0 !important;
    min-width: 0 !important;
    padding: 0 !important;
    border: 0 !important;
    opacity: 0 !important
  `}
`;
const StyledExpander = styled(Button) `
  position: relative;
  margin: 0;
  padding: 0;
  left: -5px;
  color: transparent;
  cursor: pointer;
`;
const StyledTfootComponent = styled(Box) ``;

class TableComponent extends Component {
    render() {
        return React.createElement(StyledTableComponent, Object.assign({ role: "grid" }, this.props));
    }
}

const defaultButton = (_a) => {
    var { disabled, Icon, onClick, label } = _a, other = __rest(_a, ["disabled", "Icon", "onClick", "label"]);
    return (React.createElement(Button, Object.assign({ icon: React.createElement(Icon, null), disabled: disabled, onClick: onClick, label: label, plain: true }, other)));
};
const StyledButton = styled(defaultButton) `
  width: 150px;
  padding: 10px 0;
`;
const StyledPageInput = styled(NumberInput) `
  max-width: 180px;
`;
const StyledSelect = styled(Select) `
  max-width: 150px;
`;
class ReactTablePagination extends Component {
    constructor(props, context) {
        super(props, context);
        this.getSafePage = page => {
            const pg = Number.isNaN(page) ? this.props.page : page;
            return Math.min(Math.max(pg, 0), this.props.pages - 1);
        };
        this.changePage = page => {
            const pg = this.getSafePage(page);
            this.setState({ page: pg });
            if (this.props.page !== pg) {
                this.props.onPageChange(pg);
            }
        };
        this.applyPage = e => {
            if (e) {
                e.preventDefault();
            }
            const { page } = this.state;
            this.changePage(page === '' ? this.props.page : page);
        };
        this.state = { page: props.page };
    }
    static getDerivedStateFromProps(nextProps) {
        return {
            page: nextProps.page,
        };
    }
    renderPaging() {
        const { page, showPageJump, pageText, ofText, pages } = this.props;
        let pageJump;
        if (showPageJump) {
            pageJump = (
            //@ts-ignore
            React.createElement(StyledPageInput, { "aria-label": "Select page to jump to", onChange: e => {
                    const val = e.target.value;
                    if (val === '') {
                        return this.setState({ page: val });
                    }
                    const pg = parseInt(val, 10) - 1;
                    this.setState({ page: this.getSafePage(pg) });
                    return false;
                }, value: typeof this.state.page === 'string' ? '' : this.state.page + 1, onBlur: this.applyPage, onKeyPress: e => {
                    if (e.which === 13 || e.keyCode === 13) {
                        this.applyPage(null);
                    }
                } }));
        }
        else {
            pageJump = React.createElement(Text, null, page + 1);
        }
        return (React.createElement(Box, { direction: "row", align: "center", gap: "small" },
            React.createElement(Text, null, `${pageText} `),
            pageJump,
            React.createElement("span", { style: { whiteSpace: 'nowrap' } }, `${ofText} ${pages ||
                1}`)));
    }
    renderPageSize() {
        const { showPageSizeOptions, onPageSizeChange, pageSizeOptions, pageSize, } = this.props;
        if (showPageSizeOptions) {
            return (React.createElement(Box, { direction: "row" },
                React.createElement(StyledSelect, { "aria-label": "Select rows per page", onChange: (e) => onPageSizeChange(Number(e.option.split(' ')[0])), value: `${pageSize} ${this.props.rowsText}`, options: pageSizeOptions.map(option => `${option} ${this.props.rowsText}`) })));
        }
        return null;
    }
    renderPrevious() {
        const { PreviousComponent = StyledButton, canPrevious, page } = this.props;
        return (React.createElement(Box, { direction: "row" },
            React.createElement(PreviousComponent, { "aria-label": "Move to previous page", Icon: Previous, label: this.props.previousText, onClick: canPrevious ? () => this.changePage(page - 1) : null, disabled: !canPrevious })));
    }
    renderNext() {
        const { page, canNext, NextComponent = StyledButton } = this.props;
        return (React.createElement(Box, { direction: "row" },
            React.createElement(NextComponent, { "aria-label": "Move to next page", reverse: true, Icon: Next, label: this.props.nextText, onClick: canNext ? () => this.changePage(page + 1) : null, disabled: !canNext })));
    }
    render() {
        const props = this.props.getPaginationProps(this.props);
        return (React.createElement(Box, Object.assign({}, Object.assign({
            direction: 'row',
            align: 'center',
            justify: 'between',
            fill: 'horizontal',
        }, props)),
            this.renderPrevious(),
            this.renderPaging(),
            this.renderPageSize(),
            this.renderNext()));
    }
}

const PivotValueComponent = ({ subRows, value }) => (React.createElement("span", null,
    value,
    " ",
    subRows && `(${subRows.length})`));

const TheadComponent = props => React.createElement(StyledTHeadComponent, Object.assign({}, props));

const TbodyComponent = props => React.createElement(StyledTableBodyComponent, Object.assign({}, props));

const TfootComponent = props => React.createElement(StyledTfootComponent, Object.assign({}, props));

const NoDataComponent = (_a) => {
    var { children } = _a, rest = __rest(_a, ["children"]);
    return (React.createElement(Box, Object.assign({}, rest, { align: "center", pad: "small" }), children));
};

const ResizerComponent = props => React.createElement(StyledResizerComponent, Object.assign({}, props));

const ThComponent = (_a) => {
    var { toggleSort, sort, resizable, children, pivot, hidden, sortable, expander, CellTextComponent } = _a, props = __rest(_a, ["toggleSort", "sort", "resizable", "children", "pivot", "hidden", "sortable", "expander", "CellTextComponent"]);
    if (!expander &&
        Array.isArray(children) &&
        children.length > 1 &&
        !children[0] &&
        !children[1]) {
        return null;
    }
    const { style } = props, rest = __rest(props, ["style"]);
    const childRendered = React.createElement(CellTextComponent, Object.assign({}, rest, { value: children }));
    let content;
    if (sortable) {
        const sortAsc = sort === '-sort-asc';
        const sortDesc = sort === '-sort-desc';
        let SortIcon = Blank;
        if (sortAsc || sortDesc) {
            SortIcon = sortAsc ? LinkUp : LinkDown;
        }
        content = (React.createElement(Box, { direction: "row", gap: "xsmall", align: "center" },
            childRendered,
            React.createElement(Button, { onClick: e => toggleSort && toggleSort(e) },
                React.createElement(SortIcon, null))));
    }
    else {
        content = childRendered;
    }
    const boxProps = Object.assign({ pad: 'xsmall' }, rest);
    return (React.createElement(StyledThComponent, { role: "columnheader", onClick: e => toggleSort && toggleSort(e), direction: "row", pivot: pivot, hidden: hidden, sortable: sortable, style: style, resizable: resizable },
        React.createElement(Box, Object.assign({}, boxProps, { fill: true }), content)));
};

const extractTextProps = (_a) => {
    var rest = __rest(_a, ["value", "color", "size", "truncate", "weight", "textAlign"]);
    return rest;
};
const collectTextProps = ({ color, size, truncate, weight, textAlign, }) => ({
    color,
    size,
    truncate,
    weight,
    textAlign,
});
const CellTextComponent = (_a) => {
    var { value } = _a, rest = __rest(_a, ["value"]);
    return (React.createElement(Text, Object.assign({}, collectTextProps(rest)), value));
};

const TdComponent = (_a) => {
    var { children } = _a, props = __rest(_a, ["children"]);
    const { style } = props, rest = __rest(props, ["style"]);
    const boxProps = Object.assign({ pad: 'small' }, extractTextProps(rest));
    return (React.createElement(StyledTdComponent, { style: style, role: "gridcell" },
        React.createElement(Box, Object.assign({ fill: true, align: "center", direction: "row" }, boxProps), children)));
};

const FilterComponent = (_a) => {
    var { filter, onChange, column } = _a, rest = __rest(_a, ["filter", "onChange", "column"]);
    const props = Object.assign({ size: 'medium' }, rest);
    return (React.createElement(TextInput, Object.assign({ "aria-label": `Filter data by ${typeof column.Header === 'string' ? column.Header : column.id}`, value: filter ? filter.value : '', onChange: event => onChange(event.target.value) }, props)));
};

const ExpanderComponent = ({ isExpanded, children, expanderProps, }) => {
    const props = Object.assign({
        CloseIcon: React.createElement(Subtract, null),
        OpenIcon: React.createElement(Add, null),
        tabIndex: 0,
        onClick: () => { },
    }, expanderProps);
    const { OpenIcon, CloseIcon } = props, rest = __rest(props, ["OpenIcon", "CloseIcon"]);
    return (React.createElement(StyledExpander, Object.assign({ a11yTitle: "Press Enter to expand this row for more information", icon: isExpanded ? CloseIcon : OpenIcon }, rest), children));
};

const spinkitSpinners = {
    circle: { divCount: 12 },
    'cube-grid': { divCount: 9 },
    wave: { divCount: 5 },
    'folding-cube': { divCount: 4 },
    'three-bounce': { divCount: 3 },
    'double-bounce': { divCount: 2 },
    'wandering-cubes': { divCount: 2 },
    'chasing-dots': { divCount: 2 },
    'rotating-plane': { divCount: 1 },
    pulse: { divCount: 1 },
    wordpress: { divCount: 1 },
};
const loadersCssSpinners = {
    'ball-grid-beat': { divCount: 9 },
    'ball-grid-pulse': { divCount: 9 },
    'line-spin-fade-loader': { divCount: 8 },
    'ball-spin-fade-loader': { divCount: 8 },
    'ball-pulse-rise': { divCount: 5 },
    'line-scale': { divCount: 5 },
    'line-scale-pulse-out': { divCount: 5 },
    'line-scale-pulse-out-rapid': { divCount: 5 },
    pacman: { divCount: 5 },
    'line-scale-party': { divCount: 4 },
    'ball-triangle-path': { divCount: 3 },
    'ball-scale-multiple': { divCount: 3 },
    'ball-scale-ripple-multiple': { divCount: 3 },
    'ball-pulse-sync': { divCount: 3 },
    'ball-beat': { divCount: 3 },
    'ball-zig-zag': { divCount: 2 },
    'ball-zig-zag-deflect': { divCount: 2 },
    'ball-clip-rotate-pulse': { divCount: 2 },
    'ball-clip-rotate-multiple': { divCount: 2 },
    'ball-clip-rotate': { divCount: 1 },
    'ball-scale-ripple': { divCount: 1 },
    'triangle-skew-spin': { divCount: 1 },
};
const allSpinners = Object.assign(Object.assign({}, spinkitSpinners), loadersCssSpinners);

const animationFadeIn = keyframes `
  0% { opacity: 0;}
  50% { opacity: 0;}
  100% { opacity: 1;}
`;
const animationBounceDelay = keyframes `
  0%, 80%, 100% { -webkit-transform: scale(0.0) }
  40% { -webkit-transform: scale(1.0) }
`;
const animationScaleDelay = keyframes `
  0%, 70%, 100% { -webkit-transform:scale3D(1.0, 1.0, 1.0) }
  35%           { -webkit-transform:scale3D(0.0, 0.0, 1.0) }
`;
const animationStretchDelay = keyframes `
  0%, 40%, 100% { -webkit-transform: scaleY(0.4) }
  20% { -webkit-transform: scaleY(1.0) }
`;
const animationFoldCubeAngle = keyframes `
  0%, 10% {
    -webkit-transform: perspective(140px) rotateX(-180deg);
    opacity: 0;
  } 
  25%, 75% {
    -webkit-transform: perspective(140px) rotateX(0deg);
    opacity: 1;
  } 
  90%, 100% {
    -webkit-transform: perspective(140px) rotateY(180deg);
    opacity: 0;
  }
`;
const animationBounce = keyframes `
  0%, 100% {
    -webkit-transform: scale(0.0);
  } 
  50% {
    -webkit-transform: scale(1.0);
  }
`;
const animationCubeMove = keyframes `
  25% {
    -webkit-transform: translateX(42px) rotate(-90deg) scale(0.5);
  } 
  50% {
    /* Hack to make FF rotate in the right direction */
    -webkit-transform: translateX(42px) translateY(42px) rotate(-179deg);
  } 
  50.1% {
    -webkit-transform: translateX(42px) translateY(42px) rotate(-180deg);
  } 
  75% {
    -webkit-transform: translateX(0px) translateY(42px) rotate(-270deg) scale(0.5);
  } 
  100% {
    -webkit-transform: rotate(-360deg);
  }
`;
const animationRotate = keyframes `
 100% { -webkit-transform: rotate(360deg) }
`;
const animationRotatePlane = keyframes `
  0% {
    -webkit-transform: perspective(120px) rotateX(0deg) rotateY(0deg);
  } 
  50% {
    -webkit-transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg);
  } 
  100% {
    -webkit-transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg);
  }
`;
const animationScaleOut = keyframes `
  0% { -webkit-transform: scale(0.0) }
  100% {
    -webkit-transform: scale(1.0);
    opacity: 0;
  }
`;
const animationInnerCircle = keyframes `
  0% { -webkit-transform: rotate(0); }
  100% { -webkit-transform: rotate(360deg); }
`;
const ThreeBounceSpinner = styled.div `
  ${props => normalizeColor(props.color, props.theme)}
  & >div {
    background-color: ${props => normalizeColor(props.color, props.theme)};
  }
  height: ${props => props.theme.global.edgeSize[props.size]};
  & > div {
    width: ${props => props.theme.global.edgeSize[props.size]};
    height: ${props => props.theme.global.edgeSize[props.size]};
    background-color: ${props => normalizeColor(props.color, props.theme)};
    border-radius: 100%;
    display: inline-block;
    animation: ${animationBounceDelay} 1.4s infinite ease-in-out;
    /* Prevent first frame from flickering when animation starts */
    animation-fill-mode: both;
  }
  & > div:first-child {
    animation-delay: -0.32s;
  }
  & > div:nth-child(2) {
    animation-delay: -0.16s;
  }
  animation: ${animationFadeIn} 2s;
`;
const CircleSpinner = styled.div `
  width: ${props => props.theme.global.edgeSize[props.size]};
  height: ${props => props.theme.global.edgeSize[props.size]};
  position: relative;

  & > div {
    background-color: initial;
    width: 100%;
    height: 100%;
    position: absolute;
    left: 0;
    top: 0;
  }

  & > div::before {
    content: '';
    display: block;
    margin: 0 auto;
    width: 20%;
    height: 20%;
    background-color: ${props => normalizeColor(props.color, props.theme)};
    border-radius: 100%;
    animation: ${animationBounceDelay} 1.2s infinite ease-in-out;
    /* Prevent first frame from flickering when animation starts */
    animation-fill-mode: both;
  }

  & > div:nth-child(2) {
    -webkit-transform: rotate(30deg);
    transform: rotate(30deg);
  }
  & > div:nth-child(3) {
    -webkit-transform: rotate(60deg);
    transform: rotate(60deg);
  }
  & > div:nth-child(4) {
    -webkit-transform: rotate(90deg);
    transform: rotate(90deg);
  }
  & > div:nth-child(5) {
    -webkit-transform: rotate(120deg);
    transform: rotate(120deg);
  }
  & > div:nth-child(6) {
    -webkit-transform: rotate(150deg);
    transform: rotate(150deg);
  }
  & > div:nth-child(7) {
    -webkit-transform: rotate(180deg);
    transform: rotate(180deg);
  }
  & > div:nth-child(8) {
    -webkit-transform: rotate(210deg);
    transform: rotate(210deg);
  }
  & > div:nth-child(9) {
    -webkit-transform: rotate(240deg);
    transform: rotate(240deg);
  }
  & > div:nth-child(10) {
    -webkit-transform: rotate(270deg);
    transform: rotate(270deg);
  }
  & > div:nth-child(11) {
    -webkit-transform: rotate(300deg);
    transform: rotate(300deg);
  }
  & > div:nth-child(12) {
    -webkit-transform: rotate(330deg);
    transform: rotate(330deg);
  }

  & > div:nth-child(2)::before {
    -webkit-animation-delay: -1.1s;
    animation-delay: -1.1s;
  }
  & > div:nth-child(3)::before {
    -webkit-animation-delay: -1s;
    animation-delay: -1s;
  }
  & > div:nth-child(4)::before {
    -webkit-animation-delay: -0.9s;
    animation-delay: -0.9s;
  }
  & > div:nth-child(5)::before {
    -webkit-animation-delay: -0.8s;
    animation-delay: -0.8s;
  }
  & > div:nth-child(6)::before {
    -webkit-animation-delay: -0.7s;
    animation-delay: -0.7s;
  }
  & > div:nth-child(7)::before {
    -webkit-animation-delay: -0.6s;
    animation-delay: -0.6s;
  }
  & > div:nth-child(8)::before {
    -webkit-animation-delay: -0.5s;
    animation-delay: -0.5s;
  }
  & > div:nth-child(9)::before {
    -webkit-animation-delay: -0.4s;
    animation-delay: -0.4s;
  }
  & > div:nth-child(10)::before {
    -webkit-animation-delay: -0.3s;
    animation-delay: -0.3s;
  }
  & > div:nth-child(11)::before {
    -webkit-animation-delay: -0.2s;
    animation-delay: -0.2s;
  }
  & > div:nth-child(12)::before {
    -webkit-animation-delay: -0.1s;
    animation-delay: -0.1s;
  }
`;
const CubeGridSpinner = styled.div `
  width: ${props => props.theme.global.edgeSize[props.size]};
  height: ${props => props.theme.global.edgeSize[props.size]};

  & > div {
    width: 33%;
    height: 33%;
    background-color: ${props => normalizeColor(props.color, props.theme)};
    float: left;
    animation: ${animationScaleDelay} 1.3s infinite ease-in-out;
  }

  /*
  * Spinner positions
  * 1 2 3
  * 4 5 6
  * 7 8 9
  */

  & > div:nth-child(1) {
    -webkit-animation-delay: 0.2s;
    animation-delay: 0.2s;
  }
  & > div:nth-child(2) {
    -webkit-animation-delay: 0.3s;
    animation-delay: 0.3s;
  }
  & > div:nth-child(3) {
    -webkit-animation-delay: 0.4s;
    animation-delay: 0.4s;
  }
  & > div:nth-child(4) {
    -webkit-animation-delay: 0.1s;
    animation-delay: 0.1s;
  }
  & > div:nth-child(5) {
    -webkit-animation-delay: 0.2s;
    animation-delay: 0.2s;
  }
  & > div:nth-child(6) {
    -webkit-animation-delay: 0.3s;
    animation-delay: 0.3s;
  }
  & > div:nth-child(7) {
    -webkit-animation-delay: 0s;
    animation-delay: 0s;
  }
  & > div:nth-child(8) {
    -webkit-animation-delay: 0.1s;
    animation-delay: 0.1s;
  }
  & > div:nth-child(9) {
    -webkit-animation-delay: 0.2s;
    animation-delay: 0.2s;
  }
`;
const WaveSpinner = styled.div `
  width: 30px;
  height: 27px;

  & > div {
    background-color: ${props => normalizeColor(props.color, props.theme)};
    height: 100%;
    width: 6px;
    display: inline-block;
    animation: ${animationStretchDelay} 1.2s infinite ease-in-out;
  }

  $ > div:nth-child(2) {
    animation-delay: -1.1s;
  }

  & > div:nth-child(3) {
    animation-delay: -1s;
  }

  & > div:nth-child(4) {
    animation-delay: -0.9s;
  }

  & > div:nth-child(5) {
    animation-delay: -0.8s;
  }
`;
const FoldingCubeSpinner = styled.div `
  width: ${props => props.theme.global.edgeSize[props.size]};
  height: ${props => props.theme.global.edgeSize[props.size]};
  position: relative;
  transform: rotateZ(45deg);

  & > div {
    background-color: initial;
    float: left;
    width: 50%;
    height: 50%;
    position: relative;

    -webkit-transform: scale(1.1);
    -ms-transform: scale(1.1);
    transform: scale(1.1);
  }
  & > div::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: ${props => normalizeColor(props.color, props.theme)};
    animation: ${animationFoldCubeAngle} 2.4s infinite linear both;
    transform-origin: 100% 100%;
  }
  & > div:nth-child(2) {
    transform: scale(1.1) rotateZ(90deg);
  }
  & > div:nth-child(4) {
    transform: scale(1.1) rotateZ(180deg);
  }
  & > div:nth-child(3) {
    transform: scale(1.1) rotateZ(270deg);
  }
  & > div:nth-child(2)::before {
    animation-delay: 0.3s;
  }
  & > div:nth-child(4)::before {
    animation-delay: 0.6s;
  }
  & > div:nth-child(3)::before {
    animation-delay: 0.9s;
  }
`;
const DoubleBounceSpinner = styled.div `
  width: ${props => props.theme.global.edgeSize[props.size]};
  height: ${props => props.theme.global.edgeSize[props.size]};
  position: relative;

  & > div {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: ${props => normalizeColor(props.color, props.theme)};
    opacity: 0.6;
    position: absolute;
    top: 0;
    left: 0;

    animation: ${animationBounce} 2s infinite ease-in-out;
  }

  & > div:last-child {
    -webkit-animation-delay: -1s;
    animation-delay: -1s;
  }
`;
const WanderingCubesSpinner = styled.div `
  width: 52px;
  height: 52px;
  position: relative;

  & > div {
    background-color: ${props => normalizeColor(props.color, props.theme)};
    width: 10px;
    height: 10px;
    position: absolute;
    top: 0;
    left: 0;

    animation: ${animationCubeMove} 1.8s infinite ease-in-out;
  }

  & > div:last-child {
    -webkit-animation-delay: -0.9s;
    animation-delay: -0.9s;
  }
`;
const ChasingDotsSpinner = styled.div `
  width: ${props => props.theme.global.edgeSize[props.size]};
  height: ${props => props.theme.global.edgeSize[props.size]};
  position: relative;
  animation: ${animationRotate} 2s infinite linear;

  & > div {
    width: 60%;
    height: 60%;
    display: inline-block;
    position: absolute;
    top: 0;
    background-color: ${props => normalizeColor(props.color, props.theme)};
    border-radius: 100%;
    animation: ${animationBounce} 2s infinite ease-in-out;
  }

  & > div:last-child {
    top: auto;
    bottom: 0;

    -webkit-animation-delay: -1s;
    animation-delay: -1s;
  }
`;
const RotatingPlaneSpinner = styled.div `
  width: ${props => props.theme.global.edgeSize[props.size]};
  height: ${props => props.theme.global.edgeSize[props.size]};
  background-color: ${props => normalizeColor(props.color, props.theme)};

  animation: ${animationRotatePlane} 1.2s infinite ease-in-out;
`;
const PulseSpinner = styled.div `
  width: ${props => props.theme.global.edgeSize[props.size]};
  height: ${props => props.theme.global.edgeSize[props.size]};
  background-color: ${props => normalizeColor(props.color, props.theme)};
  border-radius: 100%;
  animation: ${animationScaleOut} 1s infinite ease-in-out;
`;
const WordPressSpinner = styled.div `
  & > div {
    width: ${props => props.theme.global.edgeSize[props.size]};
    height: ${props => props.theme.global.edgeSize[props.size]};
    background-color: ${props => normalizeColor(props.color, props.theme)};
    display: inline-block;
    border-radius: ${props => props.theme.global.edgeSize[props.size]};
    position: relative;
    animation: ${animationInnerCircle} 1s linear infinite;
  }

  & > div::after {
    content: '';
    display: block;
    background-color: #fff;
    width: 8px;
    height: 8px;
    position: absolute;
    border-radius: 8px;
    top: 5px;
    left: 5px;
  }
`;

// ported to styled-componnets from
const styledComponents$1 = {
    circle: CircleSpinner,
    'three-bounce': ThreeBounceSpinner,
    'cube-grid': CubeGridSpinner,
    wave: WaveSpinner,
    'folding-cube': FoldingCubeSpinner,
    'double-bounce': DoubleBounceSpinner,
    'wandering-cubes': WanderingCubesSpinner,
    'chasing-dots': ChasingDotsSpinner,
    'rotating-plane': RotatingPlaneSpinner,
    pulse: PulseSpinner,
    wordpress: WordPressSpinner,
};
/** A spinning process indicator<br/>
 * `import { Spinning } from 'grommet-controls';`<br/>
 * `<Spinning />`<br/>
 */
const Spinning = ({ kind, fadeIn, color, size }) => {
    const spinnerInfo = allSpinners[kind] || allSpinners['three-bounce'];
    const StyledSpinning = styledComponents$1[kind];
    return (React.createElement(ThemeContext.Consumer, null, theme => (React.createElement(StyledSpinning, { color: (color || (theme.dark ? 'light-1' : 'dark-1')), fadeIn: fadeIn, theme: theme, size: size }, Array.from(Array(spinnerInfo.divCount).keys()).map((_, idx) => (React.createElement("div", { key: idx })))))));
};
Spinning.defaultProps = {
    kind: 'circle',
    fadeIn: 'full',
    color: undefined,
    size: 'medium',
};

const LoadingComponent = ({ loading }) => (React.createElement("div", null, loading && (React.createElement(Box, { align: "center", fill: "horizontal", pad: { vertical: 'large' } },
    React.createElement(Spinning, null)))));

const TrGroupComponent = props => (React.createElement(StyledTrGroupComponent, Object.assign({ role: "rowgroup" }, props)));

const focusableChildren = parent => {
    let list = [];
    if (parent && parent.childNodes) {
        parent.childNodes.forEach(node => {
            if (node.tagName) {
                list.push(node);
                if (filterByFocusable([node]).length !== 1) {
                    list = list.concat(focusableChildren(node));
                }
            }
        });
    }
    return filterByFocusable(list);
};
const focusedChildIndex = parent => {
    const focusable = focusableChildren(parent);
    const focused = document.activeElement;
    for (let i = 0; i < focusable.length; i += 1) {
        if (focusable[i] === focused) {
            return i;
        }
    }
    return 0;
};
const focusChildByIndex = (parent, index) => {
    const focusable = focusableChildren(parent);
    const focusIndex = Math.min(index, focusable.length - 1);
    if (focusIndex >= 0) {
        focusable[focusIndex].focus();
        return true;
    }
    return false;
};
const focusNextElement = parent => {
    const focusable = focusableChildren(parent);
    const focused = document.activeElement;
    let nextFocus;
    for (let i = 0; i < focusable.length; i += 1) {
        if (focusable[i] === focused) {
            if (i < focusable.length - 1) {
                nextFocus = focusable[i + 1];
            }
            break;
        }
    }
    if (nextFocus) {
        nextFocus.focus();
        return true;
    }
    return false;
};
const focusPrevElement = parent => {
    const focusable = focusableChildren(parent);
    const focused = document.activeElement;
    let prevFocus;
    for (let i = 0; i < focusable.length; i += 1) {
        if (focusable[i] === focused) {
            if (i > 0) {
                prevFocus = focusable[i - 1];
            }
            break;
        }
    }
    if (prevFocus) {
        prevFocus.focus();
        return true;
    }
    return false;
};
const hasKeyboardChildren = element => {
    const currentTag = element.tagName.toLowerCase();
    const validTags = /(input|select|textarea)$/;
    if (currentTag.match(validTags)) {
        return true;
    }
    const focusable = focusableChildren(element);
    for (let i = 0; i < focusable.length; i += 1) {
        if (focusable[i].tagName &&
            focusable[i].tagName.toLowerCase().match(validTags)) {
            return true;
        }
    }
    return false;
};

class TrComponent extends Component {
    constructor() {
        super(...arguments);
        this.selectNextRow = () => {
            const { selectRow } = this.props;
            const activeChild = focusedChildIndex(this.container);
            return selectRow(true, activeChild);
        };
        this.selectPrevRow = () => {
            const { selectRow } = this.props;
            const activeChild = focusedChildIndex(this.container);
            return selectRow(false, activeChild);
        };
        this.selectNextChild = () => {
            if (focusNextElement(this.container)) {
                return true;
            }
            return this.selectNextRow();
        };
        this.selectPrevChild = () => {
            if (focusPrevElement(this.container)) {
                return true;
            }
            return this.selectPrevRow();
        };
        this.selectFirstChild = activeIndex => focusChildByIndex(this.container, activeIndex);
    }
    render() {
        return (React.createElement(Keyboard, { onTab: e => {
                e.preventDefault();
                if (e.shiftKey) {
                    this.selectPrevChild();
                }
                else {
                    this.selectNextChild();
                }
            }, onLeft: e => {
                if (!hasKeyboardChildren(document.activeElement)) {
                    e.preventDefault();
                    this.selectPrevChild();
                }
            }, onRight: e => {
                if (!hasKeyboardChildren(document.activeElement)) {
                    e.preventDefault();
                    this.selectNextChild();
                }
            }, onUp: e => {
                if (!hasKeyboardChildren(document.activeElement)) {
                    e.preventDefault();
                    this.selectPrevRow();
                }
            }, onDown: e => {
                if (!hasKeyboardChildren(document.activeElement)) {
                    e.preventDefault();
                    this.selectNextRow();
                }
            } },
            React.createElement(StyledTrComponent, Object.assign({ direction: "row", role: "row", ref: el => {
                    // eslint-disable-next-line react/no-find-dom-node
                    this.container = findDOMNode(el);
                } }, this.props))));
    }
}

/* eslint-disable react/display-name */
const emptyObj = () => ({});
const defaultTableProps = {};
const defaultHeaderProps = {
    background: 'brand',
    border: 'all',
    align: 'center',
};
const defaultBodyProps = {
    animation: { type: 'fadeIn', duration: 2000, size: 'large' },
};
const defaultRowOddProps = {};
const defaultRowEvenProps = {};
const defaultFooterProps = { background: 'light-1' };
const defaultPaginationProps = { pad: { vertical: 'medium' } };
const defaultFilterProps = { border: 'bottom' };
const defaultFilterInputProps = { size: 'small', placeholder: 'Filter...' };
var defaultProps = {
    // General
    data: [],
    loading: false,
    showPagination: true,
    showPaginationTop: false,
    showPaginationBottom: true,
    showPageSizeOptions: true,
    pageSizeOptions: [5, 10, 20, 25, 50, 100],
    defaultPageSize: 20,
    showPageJump: true,
    collapseOnSortingChange: true,
    collapseOnPageChange: true,
    collapseOnDataChange: true,
    freezeWhenExpanded: false,
    sortable: true,
    multiSort: true,
    resizable: true,
    filterable: false,
    defaultSortDesc: false,
    defaultSorted: [],
    defaultFiltered: [],
    defaultResized: [],
    defaultExpanded: {},
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    defaultFilterMethod: (filter, row, _column) => {
        const id = filter.pivotId || filter.id;
        if (row[id] !== undefined && filter.value !== undefined) {
            return String(row[id])
                .toUpperCase()
                .startsWith(filter.value.toUpperCase());
        }
        return true;
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    defaultSortMethod: (a, b, _desc) => {
        // force null and undefined to the bottom
        a = a === null || a === undefined ? '' : a;
        b = b === null || b === undefined ? '' : b;
        // force any string values to lowercase
        a = typeof a === 'string' ? a.toLowerCase() : a;
        b = typeof b === 'string' ? b.toLowerCase() : b;
        // Return either 1 or -1 to indicate a sort priority
        if (a > b) {
            return 1;
        }
        if (a < b) {
            return -1;
        }
        // returning 0, undefined or any falsey value will use subsequent sorts or
        // the index as a tiebreaker
        return 0;
    },
    // Controlled State Props
    // page: undefined,
    // pageSize: undefined,
    // sorted: [],
    // filtered: [],
    // resized: [],
    // expanded: {},
    // Controlled State Callbacks
    onPageChange: undefined,
    onPageSizeChange: undefined,
    onSortedChange: undefined,
    onFilteredChange: undefined,
    onResizedChange: undefined,
    onExpandedChange: undefined,
    // Pivoting
    pivotBy: undefined,
    // Key Constants
    pivotValKey: '_pivotVal',
    pivotIDKey: '_pivotID',
    subRowsKey: '_subRows',
    aggregatedKey: '_aggregated',
    nestingLevelKey: '_nestingLevel',
    originalKey: '_original',
    indexKey: '_index',
    groupedByPivotKey: '_groupedByPivot',
    // Server-side Callbacks
    onFetchData: () => null,
    // Component decorators
    getProps: ({ className }) => ({ className }),
    getTableProps: ({ decorations }) => (decorations && decorations.table) || defaultTableProps,
    getTheadGroupProps: ({ decorations }) => (decorations && (decorations.headerGroup || decorations.header)) || {},
    getTheadGroupTrProps: emptyObj,
    getTheadProps: emptyObj,
    getTheadTrProps: emptyObj,
    getTheadThProps: ({ decorations }) => (decorations && decorations.header) || defaultHeaderProps,
    getTheadFilterProps: emptyObj,
    getTheadFilterTrProps: ({ decorations }) => (decorations && decorations.filterRow) || {},
    getFilterInputProps: ({ decorations }) => (decorations && decorations.filterInput) || defaultFilterInputProps,
    getTheadFilterThProps: ({ decorations }) => (decorations && decorations.filter) || defaultFilterProps,
    getTbodyProps: ({ decorations }) => (decorations && decorations.body) || defaultBodyProps,
    getTrGroupProps: emptyObj,
    getTrProps: (even, { decorations }) => {
        if (decorations) {
            let props = Object.assign({}, decorations.row);
            if (even) {
                props = Object.assign(Object.assign({}, props), (decorations.rowEven || defaultRowEvenProps));
            }
            else {
                props = Object.assign(Object.assign({}, props), (decorations.rowOdd || defaultRowOddProps));
            }
            return props;
        }
        return even ? defaultRowEvenProps : defaultRowOddProps;
    },
    getTdProps: ({ decorations }) => (decorations && decorations.cell) || {},
    getExpanderProps: ({ decorations }) => (decorations && decorations.expander) || {},
    getTfootProps: emptyObj,
    getTfootTrProps: emptyObj,
    getTfootTdProps: ({ decorations }) => (decorations && decorations.footer) || defaultFooterProps,
    getPaginationProps: ({ decorations }) => (decorations && decorations.pagination) || defaultPaginationProps,
    getLoadingProps: emptyObj,
    getNoDataProps: emptyObj,
    getResizerProps: emptyObj,
    // Global Column Defaults
    column: {
        // Renderers
        Cell: undefined,
        Header: undefined,
        Footer: undefined,
        Aggregated: undefined,
        Pivot: undefined,
        PivotValue: undefined,
        Expander: undefined,
        Filter: undefined,
        // All Columns
        sortable: undefined,
        resizable: undefined,
        filterable: undefined,
        show: true,
        minWidth: 100,
        // Cells only
        getProps: (_state, _rowInfo, column) => {
            if (column && column.decorations) {
                return column.decorations.cell || {};
            }
            return {};
        },
        // Pivot only
        aggregate: undefined,
        // Headers only
        getHeaderProps: (_state, _rowInfo, column) => (column && column.decorations && column.decorations.header) || {},
        getFilterProps: (_state, _rowInfo, column) => (column && column.decorations && column.decorations.filter) || {},
        // Footers only
        getFooterProps: (_state, _rowInfo, column) => (column && column.decorations && column.decorations.footer) || {},
        filterMethod: undefined,
        filterAll: false,
        sortMethod: undefined,
    },
    // Global Expander Column Defaults
    expanderDefaults: {
        sortable: false,
        resizable: false,
        filterable: false,
        width: 46,
    },
    pivotDefaults: {
    // extend the defaults for pivoted columns here
    },
    // Text
    previousText: 'Previous',
    nextText: 'Next',
    loadingText: 'Loading...',
    noDataText: 'No rows found',
    pageText: 'Page',
    ofText: 'of',
    rowsText: 'rows',
    // Components
    TableComponent,
    TheadComponent,
    TbodyComponent,
    TrGroupComponent,
    TrComponent,
    ThComponent,
    TdComponent,
    CellTextComponent,
    TfootComponent,
    FilterComponent,
    ExpanderComponent,
    PivotValueComponent,
    AggregatedComponent: ({ subRows, column }) => {
        const previewValues = subRows
            .filter(d => typeof d[column.id] !== 'undefined')
            .map((row, i) => (
        // eslint-disable-next-line react/no-array-index-key
        React.createElement("span", { key: i },
            row[column.id],
            i < subRows.length - 1 ? ', ' : '')));
        return React.createElement("span", null, previewValues);
    },
    PivotComponent: undefined,
    // the ExpanderComponent and PivotValueComponent at run-time in methods.js
    PaginationComponent: ReactTablePagination,
    PreviousComponent: undefined,
    NextComponent: undefined,
    LoadingComponent,
    NoDataComponent,
    ResizerComponent,
    PadRowComponent: () => React.createElement("span", null, "\u00A0"),
};

/* eslint-disable no-nested-ternary,no-shadow,no-param-reassign,
prefer-destructuring,no-mixed-operators */
class ReactTable extends Component {
    constructor(props) {
        super(props);
        this.rowRef = [];
        this.footerRef = null;
        this.filterRef = null;
        this.headerRef = null;
        this.headerGroupsRef = null;
        this.getResolvedState = (props, state) => (Object.assign(Object.assign(Object.assign(Object.assign({}, _.compactObject(this.state)), _.compactObject(this.props)), _.compactObject(state)), _.compactObject(props)));
        this.fireFetchData = () => {
            this.props.onFetchData(this.getResolvedState(), this);
        };
        this.getStateOrProp = key => _.getFirstDefined(this.state[key], this.props[key]);
        this.getMinRows = () => _.getFirstDefined(this.props.minRows, this.getStateOrProp('pageSize'));
        // User actions
        this.onPageChange = page => {
            const { onPageChange, collapseOnPageChange } = this.props;
            const newState = { page };
            if (collapseOnPageChange) {
                newState.expanded = {};
            }
            this.setStateWithData(newState, this.state, this.props, () => onPageChange && onPageChange(page));
        };
        this.onPageSizeChange = newPageSize => {
            const { onPageSizeChange } = this.props;
            const { pageSize, page } = this.getResolvedState();
            // Normalize the page to display
            const currentRow = pageSize * page;
            const newPage = Math.floor(currentRow / newPageSize);
            this.setStateWithData({
                pageSize: newPageSize,
                page: newPage,
            }, this.state, this.props, () => onPageSizeChange && onPageSizeChange(newPageSize, newPage));
        };
        this.sortColumn = (column, additive) => {
            const { sorted, skipNextSort, defaultSortDesc } = this.getResolvedState();
            const firstSortDirection = Object.prototype.hasOwnProperty.call(column, 'defaultSortDesc')
                ? column.defaultSortDesc
                : defaultSortDesc;
            const secondSortDirection = !firstSortDirection;
            // we can't stop event propagation from the column resize move handlers
            // attached to the document because of react's synthetic events
            // so we have to prevent the sort function from actually sorting
            // if we click on the column resize element within a header.
            if (skipNextSort) {
                this.setStateWithData({
                    skipNextSort: false,
                }, this.state, this.props);
                return;
            }
            const { onSortedChange } = this.props;
            let newSorted = _.clone(sorted || []).map(d => {
                d.desc = _.isSortingDesc(d);
                return d;
            });
            if (!_.isArray(column)) {
                // Single-Sort
                const existingIndex = newSorted.findIndex(d => d.id === column.id);
                if (existingIndex > -1) {
                    const existing = newSorted[existingIndex];
                    if (existing.desc === secondSortDirection) {
                        if (additive) {
                            newSorted.splice(existingIndex, 1);
                        }
                        else {
                            existing.desc = firstSortDirection;
                            newSorted = [existing];
                        }
                    }
                    else {
                        existing.desc = secondSortDirection;
                        if (!additive) {
                            newSorted = [existing];
                        }
                    }
                }
                else if (additive) {
                    newSorted.push({
                        id: column.id,
                        desc: firstSortDirection,
                    });
                }
                else {
                    newSorted = [
                        {
                            id: column.id,
                            desc: firstSortDirection,
                        },
                    ];
                }
            }
            else {
                // Multi-Sort
                const existingIndex = newSorted.findIndex(d => d.id === column[0].id);
                // Existing Sorted Column
                if (existingIndex > -1) {
                    const existing = newSorted[existingIndex];
                    if (existing.desc === secondSortDirection) {
                        if (additive) {
                            newSorted.splice(existingIndex, column.length);
                        }
                        else {
                            column.forEach((_d, i) => {
                                newSorted[existingIndex + i].desc = firstSortDirection;
                            });
                        }
                    }
                    else {
                        column.forEach((_d, i) => {
                            newSorted[existingIndex + i].desc = secondSortDirection;
                        });
                    }
                    if (!additive) {
                        newSorted = newSorted.slice(existingIndex, column.length);
                    }
                    // New Sort Column
                }
                else if (additive) {
                    newSorted = newSorted.concat(column.map(d => ({
                        id: d.id,
                        desc: firstSortDirection,
                    })));
                }
                else {
                    newSorted = column.map(d => ({
                        id: d.id,
                        desc: firstSortDirection,
                    }));
                }
            }
            this.setStateWithData({
                page: (!sorted.length && newSorted.length) || !additive
                    ? 0
                    : this.state.page,
                sorted: newSorted,
            }, this.state, this.props, () => onSortedChange && onSortedChange(newSorted, column, additive));
        };
        this.filterColumn = (column, value) => {
            const { filtered } = this.getResolvedState();
            const { onFilteredChange } = this.props;
            // Remove old filter first if it exists
            const newFiltering = (filtered || []).filter(x => x.id !== column.id);
            if (value !== '') {
                newFiltering.push({
                    id: column.id,
                    value,
                });
            }
            this.setStateWithData({
                filtered: newFiltering,
            }, this.state, this.props, () => onFilteredChange && onFilteredChange(newFiltering, column, value));
        };
        this.resizeColumnStart = (event, column, isTouch) => {
            event.stopPropagation();
            const parentWidth = event.target.parentElement.getBoundingClientRect()
                .width;
            let pageX;
            if (isTouch) {
                pageX = event.changedTouches[0].pageX;
            }
            else {
                pageX = event.pageX;
            }
            this.setStateWithData({
                currentlyResizing: {
                    id: column.id,
                    startX: pageX,
                    parentWidth,
                },
            }, this.state, this.props, () => {
                if (isTouch) {
                    document.addEventListener('touchmove', this.resizeColumnMoving);
                    document.addEventListener('touchcancel', this.resizeColumnEnd);
                    document.addEventListener('touchend', this.resizeColumnEnd);
                }
                else {
                    document.addEventListener('mousemove', this.resizeColumnMoving);
                    document.addEventListener('mouseup', this.resizeColumnEnd);
                    document.addEventListener('mouseleave', this.resizeColumnEnd);
                }
            });
        };
        this.resizeColumnMoving = event => {
            event.stopPropagation();
            const { onResizedChange } = this.props;
            const { resized, currentlyResizing } = this.getResolvedState();
            // Delete old value
            const newResized = resized.filter(x => x.id !== currentlyResizing.id);
            let pageX;
            if (event.type === 'touchmove') {
                pageX = event.changedTouches[0].pageX;
            }
            else if (event.type === 'mousemove') {
                pageX = event.pageX;
            }
            // Set the min size to 10 to account for margin and border or else the
            // group headers don't line up correctly
            const newWidth = Math.max(currentlyResizing.parentWidth + pageX - currentlyResizing.startX, 11);
            newResized.push({
                id: currentlyResizing.id,
                value: newWidth,
            });
            this.setStateWithData({
                resized: newResized,
            }, this.state, this.props, () => onResizedChange && onResizedChange(newResized, event));
        };
        this.resizeColumnEnd = event => {
            event.stopPropagation();
            const isTouch = event.type === 'touchend' || event.type === 'touchcancel';
            if (isTouch) {
                document.removeEventListener('touchmove', this.resizeColumnMoving);
                document.removeEventListener('touchcancel', this.resizeColumnEnd);
                document.removeEventListener('touchend', this.resizeColumnEnd);
            }
            // If its a touch event clear the mouse one's as well because sometimes
            // the mouseDown event gets called as well, but the mouseUp event doesn't
            document.removeEventListener('mousemove', this.resizeColumnMoving);
            document.removeEventListener('mouseup', this.resizeColumnEnd);
            document.removeEventListener('mouseleave', this.resizeColumnEnd);
            // The touch events don't propagate up to the sorting's onMouseDown event so
            // no need to prevent it from happening or else the first click after a touch
            // event resize will not sort the column.
            if (!isTouch) {
                this.setStateWithData({
                    skipNextSort: true,
                    currentlyResizing: undefined,
                }, this.state, this.props);
            }
        };
        this.rowRef = [];
        this.state = {
            page: 0,
            pageSize: props.defaultPageSize,
            sorted: props.defaultSorted,
            expanded: props.defaultExpanded,
            filtered: props.defaultFiltered,
            resized: props.defaultResized,
            currentlyResizing: undefined,
            skipNextSort: false,
        };
    }
    componentDidMount() {
        this.fireFetchData();
    }
    static getDerivedStateFromProps(nextProps, oldState) {
        const newState = Object.assign(Object.assign({}, oldState), nextProps);
        // Do a deep compare of new and old `defaultOption` and
        // if they are different reset `option = defaultOption`
        const defaultableOptions = ['sorted', 'filtered', 'resized', 'expanded'];
        defaultableOptions.forEach(x => {
            const defaultName = `default${x.charAt(0).toUpperCase() + x.slice(1)}`;
            if (JSON.stringify(oldState[defaultName]) !==
                JSON.stringify(newState[defaultName])) {
                newState[x] = newState[defaultName];
            }
        });
        // If they change these table options, we need to reset defaults
        // or else we could get into a state where the user has changed the UI
        // and then disabled the ability to change it back.
        // e.g. If `filterable` has changed, set `filtered = defaultFiltered`
        const resettableOptions = ['sortable', 'filterable', 'resizable'];
        resettableOptions.forEach(x => {
            if (oldState[x] !== newState[x]) {
                const baseName = x.replace('able', '');
                const optionName = `${baseName}ed`;
                const defaultName = `default${optionName.charAt(0).toUpperCase() +
                    optionName.slice(1)}`;
                newState[optionName] = newState[defaultName];
            }
        });
        // Props that trigger a data update
        if (oldState.data !== newState.data ||
            JSON.stringify(oldState.columns) !== JSON.stringify(newState.columns) ||
            oldState.pivotBy !== newState.pivotBy ||
            oldState.sorted !== newState.sorted ||
            oldState.filtered !== newState.filtered) {
            return ReactTable.getStateWithData(ReactTable.getDataModel(newState, nextProps), oldState, nextProps);
        }
        return null;
    }
    static getStateWithData(newState, oldState, props) {
        const newResolvedState = Object.assign(Object.assign(Object.assign({}, oldState), newState), props);
        const { freezeWhenExpanded } = newResolvedState;
        // Default to unfrozen state
        newResolvedState.frozen = false;
        // If freezeWhenExpanded is set, check for frozen conditions
        if (freezeWhenExpanded) {
            // if any rows are expanded, freeze the existing data and sorting
            const keys = Object.keys(newResolvedState.expanded);
            for (let i = 0; i < keys.length; i += 1) {
                if (newResolvedState.expanded[keys[i]]) {
                    newResolvedState.frozen = true;
                    break;
                }
            }
        }
        // If the data isn't frozen and either the data or
        // sorting model has changed, update the data
        if ((oldState.frozen && !newResolvedState.frozen) ||
            oldState.sorted !== newResolvedState.sorted ||
            oldState.filtered !== newResolvedState.filtered ||
            oldState.showFilters !== newResolvedState.showFilters ||
            (!newResolvedState.frozen &&
                oldState.resolvedData !== newResolvedState.resolvedData)) {
            // Handle collapseOnsortedChange & collapseOnDataChange
            if ((oldState.sorted !== newResolvedState.sorted &&
                props.collapseOnSortingChange) ||
                oldState.filtered !== newResolvedState.filtered ||
                oldState.showFilters !== newResolvedState.showFilters ||
                (oldState.sortedData &&
                    !newResolvedState.frozen &&
                    oldState.resolvedData !== newResolvedState.resolvedData &&
                    props.collapseOnDataChange)) {
                newResolvedState.expanded = {};
            }
            Object.assign(newResolvedState, ReactTable.getSortedData(newResolvedState, props));
        }
        // Set page to 0 if filters change
        if (oldState.filtered !== newResolvedState.filtered) {
            newResolvedState.page = 0;
        }
        // Calculate pageSize all the time
        if (newResolvedState.sortedData) {
            newResolvedState.pages = newResolvedState.manual
                ? newResolvedState.pages
                : Math.ceil(newResolvedState.sortedData.length / newResolvedState.pageSize);
            newResolvedState.page = Math.max(newResolvedState.page >= newResolvedState.pages
                ? newResolvedState.pages - 1
                : newResolvedState.page, 0);
        }
        return newResolvedState;
    }
    setStateWithData(newState, oldState, props, cb) {
        const newResolvedState = ReactTable.getStateWithData(newState, oldState, props);
        return this.setState(newResolvedState, () => {
            if (cb) {
                cb();
            }
            if (oldState.page !== newResolvedState.page ||
                oldState.pageSize !== newResolvedState.pageSize ||
                oldState.sorted !== newResolvedState.sorted ||
                oldState.filtered !== newResolvedState.filtered) {
                this.fireFetchData();
            }
        });
    }
    render() {
        const resolvedState = this.getResolvedState();
        const { getProps, getTableProps, getTheadGroupProps, getTheadGroupTrProps, getTheadProps, getTheadTrProps, getTheadThProps, getTheadFilterProps, getTheadFilterTrProps, getTheadFilterThProps, getFilterInputProps, getTbodyProps, getTrGroupProps, getTrProps, getTdProps, getExpanderProps, getTfootProps, getTfootTrProps, getTfootTdProps, getPaginationProps, getLoadingProps, getNoDataProps, getResizerProps, showPagination, showPaginationTop, showPaginationBottom, manual, loadingText, noDataText, sortable, multiSort, resizable, filterable, 
        // Pivoting State
        pivotIDKey, pivotValKey, pivotBy, subRowsKey, aggregatedKey, originalKey, indexKey, groupedByPivotKey, expanderTdDefaultProps, 
        // State
        loading, pageSize, page, sorted, filtered, resized, expanded, pages, onExpandedChange, 
        // Components
        TableComponent, TheadComponent, TbodyComponent, TrGroupComponent, TrComponent, ThComponent, TdComponent, CellTextComponent, TfootComponent, PaginationComponent, LoadingComponent, SubComponent, NoDataComponent, ResizerComponent, ExpanderComponent, PivotValueComponent, PivotComponent, AggregatedComponent, FilterComponent, PadRowComponent, 
        // Data model
        resolvedData, allVisibleColumns, headerGroups, hasHeaderGroups, 
        // Sorted Data
        sortedData, } = resolvedState;
        // Pagination
        const startRow = pageSize * page;
        const endRow = startRow + pageSize;
        let pageRows = manual ? resolvedData : sortedData.slice(startRow, endRow);
        const minRows = this.getMinRows();
        const padRows = _.range(Math.max(minRows - pageRows.length, 0));
        const hasColumnFooter = allVisibleColumns.some(d => d.Footer);
        const hasFilters = filterable || allVisibleColumns.some(d => d.filterable);
        const recurseRowsViewIndex = (rows, path = [], index = -1) => [
            rows.map((row, i) => {
                index += 1;
                const rowWithViewIndex = Object.assign(Object.assign({}, row), { viewIndex: index });
                const newPath = path.concat([i]);
                if (rowWithViewIndex[subRowsKey] && _.get(expanded, newPath)) {
                    [rowWithViewIndex[subRowsKey], index] = recurseRowsViewIndex(rowWithViewIndex[subRowsKey], newPath, index);
                }
                return rowWithViewIndex;
            }),
            index,
        ];
        [pageRows] = recurseRowsViewIndex(pageRows);
        const canPrevious = page > 0;
        const canNext = page + 1 < pages;
        const rowMinWidth = _.sum(allVisibleColumns.map(d => {
            const resizedColumn = resized.find(x => x.id === d.id) || {
                id: undefined,
                value: undefined,
            };
            return _.getFirstDefined(resizedColumn.value, d.width, d.minWidth);
        }));
        let rowIndex = -1;
        const finalState = Object.assign(Object.assign({}, resolvedState), { startRow,
            endRow,
            pageRows,
            minRows,
            padRows,
            hasColumnFooter,
            canPrevious,
            canNext,
            rowMinWidth });
        const rootProps = getProps(finalState, undefined, undefined, this);
        const tableProps = getTableProps(finalState, undefined, undefined, this);
        const tBodyProps = getTbodyProps(finalState, undefined, undefined, this);
        const loadingProps = getLoadingProps(finalState, undefined, undefined, this);
        const noDataProps = getNoDataProps(finalState, undefined, undefined, this);
        // Visual Components
        const makeHeaderGroup = (column, i) => {
            const resizedValue = col => (resized.find(x => x.id === col.id) || {
                id: undefined,
                value: undefined,
            }).value;
            const flex = _.sum(column.columns.map(col => col.width || resizedValue(col) ? 0 : col.minWidth));
            const width = _.sum(column.columns.map(col => _.getFirstDefined(resizedValue(col), col.width, col.minWidth)));
            const maxWidth = _.sum(column.columns.map(col => _.getFirstDefined(resizedValue(col), col.width, col.maxWidth)));
            const theadGroupThProps = getTheadGroupProps(finalState, undefined, column, this);
            const columnHeaderProps = column.getHeaderProps(finalState, undefined, column, this);
            const rest = Object.assign(Object.assign(Object.assign({}, theadGroupThProps), columnHeaderProps), { CellTextComponent });
            const flexStyles = {
                flex: `${flex} 0 auto`,
                width: _.asPx(width),
                maxWidth: _.asPx(maxWidth),
            };
            return (React.createElement(ThComponent, Object.assign({ key: `${i}-${column.id}`, style: flexStyles }, rest), _.normalizeComponent(column.Header, {
                data: sortedData,
                column,
            })));
        };
        const selectRow = index => (nextRow, childIndex) => {
            const selectFirstAvailable = rows => {
                for (let i = 0; i < rows.length; i += 1) {
                    if (rows[i]) {
                        return rows[i].selectFirstChild(childIndex);
                    }
                }
                return false;
            };
            let found;
            if (typeof index === 'number') {
                const { page, pages } = this.state;
                if (nextRow) {
                    if (pageRows.length > index + 1) {
                        found = this.rowRef[index + 1].selectFirstChild(childIndex);
                    }
                    else if (page < pages - 1) {
                        this.onPageChange(page + 1);
                        found = true;
                    }
                    else {
                        found = selectFirstAvailable([this.footerRef]);
                    }
                }
                else if (index > 0) {
                    found = this.rowRef[index - 1].selectFirstChild(childIndex);
                }
                else if (page > 0) {
                    this.onPageChange(page - 1);
                    found = true;
                }
                else {
                    found = selectFirstAvailable([
                        this.filterRef,
                        this.headerRef,
                        this.headerGroupsRef,
                    ]);
                }
            }
            if (!found) {
                if (nextRow) {
                    focusNextElement(document);
                }
                else {
                    focusPrevElement(document);
                }
            }
        };
        const makeHeaderGroups = () => {
            const theadGroupProps = getTheadGroupProps(finalState, undefined, undefined, this);
            const theadGroupTrProps = getTheadGroupTrProps(finalState, undefined, undefined, this);
            return (React.createElement(TheadComponent, Object.assign({ style: { minWidth: `${rowMinWidth}px` } }, theadGroupProps),
                React.createElement(TrComponent, Object.assign({ ref: el => {
                        this.headerGroupsRef = el;
                    }, selectRow: selectRow('headerGroup') }, theadGroupTrProps), headerGroups.map(makeHeaderGroup))));
        };
        const makeHeader = (column, i) => {
            const resizedCol = resized.find(x => x.id === column.id) || {
                id: undefined,
                value: undefined,
            };
            const sort = sorted.find(d => d.id === column.id);
            const show = typeof column.show === 'function' ? column.show() : column.show;
            const width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
            const maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
            const theadThProps = getTheadThProps(finalState, undefined, column, this);
            const columnHeaderProps = column.getHeaderProps(finalState, undefined, column, this);
            const rest = Object.assign(Object.assign(Object.assign({}, theadThProps), columnHeaderProps), { CellTextComponent });
            const isResizable = _.getFirstDefined(column.resizable, resizable, false);
            const resizer = isResizable ? (React.createElement(ResizerComponent, Object.assign({ onMouseDown: e => this.resizeColumnStart(e, column, false), onTouchStart: e => this.resizeColumnStart(e, column, true) }, getResizerProps(finalState, undefined, column, this)))) : null;
            const isSortable = _.getFirstDefined(column.sortable, sortable, false);
            return (React.createElement(ThComponent, Object.assign({ key: `${i}-${column.id}`, sort: sort && (sort.desc ? '-sort-desc' : '-sort-asc'), resizable: isResizable, sortable: isSortable, hidden: !show, expander: column.expander, pivot: pivotBy && pivotBy.slice(0, -1).includes(column.id), style: {
                    flex: `${width} 0 auto`,
                    width: _.asPx(width),
                    maxWidth: _.asPx(maxWidth),
                }, toggleSort: e => {
                    if (isSortable)
                        this.sortColumn(column, multiSort ? e.shiftKey : false);
                } }, rest),
                _.normalizeComponent(column.Header, {
                    data: sortedData,
                    column,
                }),
                resizer));
        };
        const makeHeaders = () => {
            const theadProps = getTheadProps(finalState, undefined, undefined, this);
            const theadTrProps = getTheadTrProps(finalState, undefined, undefined, this);
            return (React.createElement(TheadComponent, Object.assign({ header: true, style: {
                    minWidth: `${rowMinWidth}px`,
                } }, theadProps),
                React.createElement(TrComponent, Object.assign({ ref: el => {
                        this.headerRef = el;
                    }, selectRow: selectRow('header') }, theadTrProps), allVisibleColumns.map(makeHeader))));
        };
        const makeFilter = (column, i) => {
            const resizedCol = resized.find(x => x.id === column.id) || {
                id: undefined,
                value: undefined,
            };
            const width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
            const maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
            const theadFilterThProps = getTheadFilterThProps(finalState, undefined, column, this);
            const filterInputProps = getFilterInputProps(finalState, undefined, column, this);
            const columnHeaderProps = column.getFilterProps(finalState, undefined, column, this);
            const rest = Object.assign(Object.assign(Object.assign({}, theadFilterThProps), columnHeaderProps), { CellTextComponent });
            const filter = filtered.find(filter => filter.id === column.id);
            const ResolvedFilterComponent = column.Filter || FilterComponent;
            const isFilterable = _.getFirstDefined(column.filterable, filterable, false);
            return (React.createElement(ThComponent, Object.assign({ key: `${i}-${column.id}`, style: {
                    flex: `${width} 0 auto`,
                    width: _.asPx(width),
                    maxWidth: _.asPx(maxWidth),
                } }, rest), isFilterable
                ? _.normalizeComponent(ResolvedFilterComponent, Object.assign(Object.assign({}, filterInputProps), { column,
                    filter, onChange: value => this.filterColumn(column, value) }), undefined)
                : null));
        };
        const makeFilters = () => {
            const theadFilterProps = getTheadFilterProps(finalState, undefined, undefined, this);
            const theadFilterTrProps = getTheadFilterTrProps(finalState, undefined, undefined, this);
            return (React.createElement(TheadComponent, Object.assign({ filters: true, style: {
                    minWidth: `${rowMinWidth}px`,
                } }, theadFilterProps),
                React.createElement(TrComponent, Object.assign({ ref: el => {
                        this.filterRef = el;
                    }, selectRow: selectRow('filter') }, theadFilterTrProps), allVisibleColumns.map(makeFilter))));
        };
        const makePageRow = (row, i, path = []) => {
            const rowInfo = {
                original: row[originalKey],
                row,
                index: row[indexKey],
                viewIndex: rowIndex += 1,
                pageSize,
                page,
                level: path.length,
                nestingPath: path.concat([i]),
                aggregated: row[aggregatedKey],
                groupedByPivot: row[groupedByPivotKey],
                subRows: row[subRowsKey],
            };
            const isExpanded = _.get(expanded, rowInfo.nestingPath);
            const trGroupProps = getTrGroupProps(finalState, rowInfo, undefined, this);
            const expanderProps = getExpanderProps(finalState, rowInfo, undefined, this);
            const trProps = getTrProps(row.viewIndex % 2, finalState, rowInfo, undefined, this);
            return (React.createElement(TrGroupComponent, Object.assign({ key: rowInfo.nestingPath.join('_') }, trGroupProps),
                React.createElement(TrComponent, Object.assign({ selectRow: selectRow(i), ref: el => {
                        this.rowRef[i] = el;
                    }, rowIndex: row.viewIndex }, trProps), allVisibleColumns.map((column, i2) => {
                    let defaultTdProps = {};
                    const resizedCol = resized.find(x => x.id === column.id) || {
                        id: undefined,
                        value: undefined,
                    };
                    const show = typeof column.show === 'function' ? column.show() : column.show;
                    const width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
                    const maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
                    const tdProps = getTdProps(finalState, rowInfo, column, this);
                    const columnProps = column.getProps(finalState, rowInfo, column);
                    const cellInfo = Object.assign(Object.assign(Object.assign(Object.assign({}, rowInfo), { isExpanded, column: Object.assign({}, column), value: rowInfo.row[column.id], pivoted: column.pivoted, expander: column.expander, expandable: undefined, resized,
                        show,
                        width,
                        maxWidth }), tdProps), columnProps);
                    let value = cellInfo.value;
                    let useOnExpanderClick;
                    let isBranch;
                    let isPreview;
                    const onExpanderClick = e => {
                        let newExpanded = _.clone(expanded);
                        if (isExpanded) {
                            newExpanded = _.set(newExpanded, cellInfo.nestingPath, false);
                        }
                        else {
                            newExpanded = _.set(newExpanded, cellInfo.nestingPath, {});
                        }
                        return this.setStateWithData({
                            expanded: newExpanded,
                        }, this.state, this.props, () => onExpandedChange &&
                            onExpandedChange(newExpanded, cellInfo.nestingPath, e));
                    };
                    // Default to a standard cell
                    if (column.Cell) {
                        value = _.normalizeComponent(column.Cell, cellInfo, value);
                    }
                    const cellProps = Object.assign(Object.assign({}, tdProps), columnProps);
                    let resolvedCell = (React.createElement(CellTextComponent, Object.assign({ value: value }, cellProps)));
                    // Resolve Renderers
                    const ResolvedAggregatedComponent = column.Aggregated ||
                        (!column.aggregate ? AggregatedComponent : column.Cell);
                    const ResolvedExpanderComponent = column.Expander || ExpanderComponent;
                    const ResolvedPivotValueComponent = column.PivotValue || PivotValueComponent;
                    const DefaultResolvedPivotComponent = PivotComponent ||
                        (props => (React.createElement(React.Fragment, null,
                            React.createElement(ResolvedExpanderComponent, Object.assign({}, Object.assign(Object.assign({}, props), { expanderProps }))),
                            React.createElement(ResolvedPivotValueComponent, Object.assign({}, props)))));
                    const ResolvedPivotComponent = column.Pivot || DefaultResolvedPivotComponent;
                    // Is this cell expandable?
                    if (cellInfo.pivoted || cellInfo.expander) {
                        // Make it expandable by defualt
                        cellInfo.expandable = true;
                        useOnExpanderClick = true;
                        // If pivoted, has no subRows, and does not have a subComponent,
                        // do not make expandable
                        if (cellInfo.pivoted && !cellInfo.subRows && !SubComponent) {
                            cellInfo.expandable = false;
                        }
                    }
                    if (cellInfo.pivoted) {
                        // Is this column a branch?
                        isBranch =
                            rowInfo.row[pivotIDKey] === column.id && cellInfo.subRows;
                        // Should this column be blank?
                        isPreview =
                            pivotBy.indexOf(column.id) >
                                pivotBy.indexOf(rowInfo.row[pivotIDKey]) &&
                                cellInfo.subRows;
                        // Pivot Cell Render Override
                        if (isBranch) {
                            // isPivot
                            resolvedCell = _.normalizeComponent(ResolvedPivotComponent, Object.assign(Object.assign({}, cellInfo), { value: row[pivotValKey] }), row[pivotValKey]);
                        }
                        else if (isPreview) {
                            // Show the pivot preview
                            resolvedCell = _.normalizeComponent(ResolvedAggregatedComponent, cellInfo, value);
                        }
                        else {
                            resolvedCell = null;
                        }
                    }
                    else if (cellInfo.aggregated) {
                        resolvedCell = _.normalizeComponent(ResolvedAggregatedComponent, cellInfo, value);
                    }
                    if (cellInfo.expander) {
                        defaultTdProps = expanderTdDefaultProps;
                        resolvedCell = _.normalizeComponent(ResolvedExpanderComponent, Object.assign(Object.assign({}, cellInfo), { expanderProps }), row[pivotValKey]);
                        if (pivotBy) {
                            if (cellInfo.groupedByPivot) {
                                resolvedCell = null;
                            }
                            if (!cellInfo.subRows && !SubComponent) {
                                resolvedCell = null;
                            }
                        }
                    }
                    const resolvedOnExpanderClick = useOnExpanderClick
                        ? onExpanderClick
                        : () => { };
                    // If there are multiple onClick events, make sure they don't
                    // override eachother. This should maybe be expanded to handle all
                    // function attributes
                    const interactionProps = {
                        onClick: resolvedOnExpanderClick,
                    };
                    if (tdProps.onClick) {
                        interactionProps.onClick = e => {
                            tdProps.onClick(e, () => resolvedOnExpanderClick(e));
                        };
                    }
                    if (columnProps.onClick) {
                        interactionProps.onClick = e => {
                            columnProps.onClick(e, () => resolvedOnExpanderClick(e));
                        };
                    }
                    // Return the cell
                    return (React.createElement(TdComponent
                    // eslint-disable-next-line react/no-array-index-key
                    , Object.assign({ 
                        // eslint-disable-next-line react/no-array-index-key
                        key: `${i2}-${column.id}`, hidden: !show, style: {
                            flex: `${width} 0 auto`,
                            width: _.asPx(width),
                            maxWidth: _.asPx(maxWidth),
                        } }, tdProps, columnProps, interactionProps, defaultTdProps), resolvedCell));
                })),
                rowInfo.subRows &&
                    isExpanded &&
                    rowInfo.subRows.map((d, i) => makePageRow(d, i, rowInfo.nestingPath)),
                SubComponent &&
                    !rowInfo.subRows &&
                    isExpanded &&
                    SubComponent(rowInfo)));
        };
        const makePadColumn = (column, i) => {
            const resizedCol = resized.find(x => x.id === column.id) || {
                id: undefined,
                value: undefined,
            };
            const show = typeof column.show === 'function' ? column.show() : column.show;
            const width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
            const flex = width;
            const maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
            const tdProps = getTdProps(finalState, undefined, column, this);
            return (React.createElement(TdComponent, Object.assign({ key: `${i}-${column.id}`, hidden: !show, style: {
                    flex: `${flex} 0 auto`,
                    width: _.asPx(width),
                    maxWidth: _.asPx(maxWidth),
                } }, tdProps), _.normalizeComponent(PadRowComponent)));
        };
        const makePadRow = (row, i) => {
            const trGroupProps = getTrGroupProps(finalState, undefined, undefined, this);
            const trProps = getTrProps(row.viewIndex % 2, finalState, undefined, undefined, this);
            return (React.createElement(TrGroupComponent, Object.assign({ key: i }, trGroupProps),
                React.createElement(TrComponent, Object.assign({ padrow: true, even: (pageRows.length + i) % 2 }, trProps), allVisibleColumns.map(makePadColumn))));
        };
        const makeColumnFooter = (column, i) => {
            const resizedCol = resized.find(x => x.id === column.id) || {
                id: undefined,
                value: undefined,
            };
            const show = typeof column.show === 'function' ? column.show() : column.show;
            const width = _.getFirstDefined(resizedCol.value, column.width, column.minWidth);
            const maxWidth = _.getFirstDefined(resizedCol.value, column.width, column.maxWidth);
            const tFootTdProps = getTfootTdProps(finalState, undefined, undefined, this);
            const columnProps = column.getProps(finalState, undefined, column, this);
            const columnFooterProps = column.getFooterProps(finalState, undefined, column, this);
            return (React.createElement(TdComponent, Object.assign({ key: `${i}-${column.id}`, hidden: !show, style: {
                    flex: `${width} 0 auto`,
                    width: _.asPx(width),
                    maxWidth: _.asPx(maxWidth),
                } }, columnProps, tFootTdProps, columnFooterProps), _.normalizeComponent(column.Footer, {
                data: sortedData,
                column,
            })));
        };
        const makeColumnFooters = () => {
            const tFootProps = getTfootProps(finalState, undefined, undefined, this);
            const tFootTrProps = getTfootTrProps(finalState, undefined, undefined, this);
            return (React.createElement(TfootComponent, Object.assign({ style: {
                    minWidth: `${rowMinWidth}px`,
                } }, tFootProps),
                React.createElement(TrComponent, Object.assign({ ref: el => {
                        this.footerRef = el;
                    }, selectRow: selectRow('footer') }, tFootTrProps), allVisibleColumns.map(makeColumnFooter))));
        };
        const makePagination = () => {
            const paginationProps = getPaginationProps(finalState, undefined, undefined, this);
            return (React.createElement(PaginationComponent, Object.assign({}, resolvedState, { pages: pages, canPrevious: canPrevious, canNext: canNext, onPageChange: this.onPageChange, onPageSizeChange: this.onPageSizeChange }, paginationProps)));
        };
        const makeTable = () => {
            const pagination = makePagination();
            return (React.createElement("div", Object.assign({}, rootProps),
                showPagination && showPaginationTop ? React.createElement("div", null, pagination) : null,
                React.createElement(TableComponent, Object.assign({}, tableProps),
                    hasHeaderGroups ? makeHeaderGroups() : null,
                    makeHeaders(),
                    hasFilters ? makeFilters() : null,
                    React.createElement(TbodyComponent, Object.assign({ style: {
                            minWidth: `${rowMinWidth}px`,
                        } }, tBodyProps),
                        React.createElement(LoadingComponent, Object.assign({ loading: loading, loadingText: loadingText }, loadingProps)),
                        pageRows.map((d, i) => makePageRow(d, i)),
                        padRows.map(makePadRow)),
                    hasColumnFooter ? makeColumnFooters() : null),
                showPagination && showPaginationBottom ? (React.createElement("div", null, pagination)) : null,
                !pageRows.length && !loading && (React.createElement(NoDataComponent, Object.assign({}, noDataProps), _.normalizeComponent(noDataText)))));
        };
        // childProps are optionally passed to a function-as-a-child
        return makeTable();
    }
}
ReactTable.defaultProps = defaultProps;
ReactTable.getDataModel = (newState, props) => {
    const { columns, pivotBy = [], data, pivotIDKey, pivotValKey, subRowsKey, aggregatedKey, nestingLevelKey, originalKey, indexKey, groupedByPivotKey, SubComponent, } = newState;
    // Determine Header Groups
    let hasHeaderGroups = false;
    columns.forEach(column => {
        if (column.columns) {
            hasHeaderGroups = true;
        }
    });
    let columnsWithExpander = [...columns];
    let expanderColumn = columns.find(col => col.expander ||
        (col.columns && col.columns.some(col2 => col2.expander)));
    // The actual expander might be in the columns field of a group column
    if (expanderColumn && !expanderColumn.expander) {
        expanderColumn = expanderColumn.columns.find(col => col.expander);
    }
    // If we have SubComponent's we need to make sure we have an expander column
    if (SubComponent && !expanderColumn) {
        expanderColumn = { expander: true };
        columnsWithExpander = [expanderColumn, ...columnsWithExpander];
    }
    const makeDecoratedColumn = (column, parentColumn) => {
        let dcol;
        if (column.expander) {
            dcol = Object.assign(Object.assign(Object.assign({}, props.column), props.expanderDefaults), column);
        }
        else {
            dcol = Object.assign(Object.assign({}, props.column), column);
        }
        // Ensure minWidth is not greater than maxWidth if set
        if (dcol.maxWidth < dcol.minWidth) {
            dcol.minWidth = dcol.maxWidth;
        }
        if (parentColumn) {
            dcol.parentColumn = parentColumn;
        }
        // First check for string accessor
        if (typeof dcol.accessor === 'string') {
            dcol.id = dcol.id || dcol.accessor;
            const accessorString = dcol.accessor;
            dcol.accessor = row => _.get(row, accessorString);
            return dcol;
        }
        // Fall back to functional accessor (but require an ID)
        if (dcol.accessor && !dcol.id) {
            console.warn(dcol);
            throw new Error('A column id is required if using a non-string accessor for column above.');
        }
        // Fall back to an undefined accessor
        if (!dcol.accessor) {
            dcol.accessor = () => undefined;
        }
        return dcol;
    };
    const allDecoratedColumns = [];
    // Decorate the columns
    const decorateAndAddToAll = (column, parentColumn) => {
        const decoratedColumn = makeDecoratedColumn(column, parentColumn);
        allDecoratedColumns.push(decoratedColumn);
        return decoratedColumn;
    };
    const decoratedColumns = columnsWithExpander.map(column => {
        if (column.columns) {
            return Object.assign(Object.assign({}, column), { columns: column.columns.map(d => decorateAndAddToAll(d, column)) });
        }
        return decorateAndAddToAll(column);
    });
    // Build the visible columns, headers and flat column list
    let visibleColumns = decoratedColumns.slice();
    let allVisibleColumns = [];
    visibleColumns = visibleColumns.map(column => {
        if (column.columns) {
            const visibleSubColumns = column.columns.filter(d => pivotBy.indexOf(d.id) > -1 ? false : _.getFirstDefined(d.show, true));
            return Object.assign(Object.assign({}, column), { columns: visibleSubColumns });
        }
        return column;
    });
    visibleColumns = visibleColumns.filter(column => column.columns
        ? column.columns.length
        : pivotBy.indexOf(column.id) > -1
            ? false
            : _.getFirstDefined(column.show, true));
    // Find any custom pivot location
    const pivotIndex = visibleColumns.findIndex(col => col.pivot);
    // Handle Pivot Columns
    if (pivotBy.length) {
        // Retrieve the pivot columns in the correct pivot order
        const pivotColumns = [];
        pivotBy.forEach(pivotID => {
            const found = allDecoratedColumns.find(d => d.id === pivotID);
            if (found) {
                pivotColumns.push(found);
            }
        });
        const PivotParentColumn = pivotColumns.reduce((prev, current) => prev && prev === current.parentColumn && current.parentColumn, pivotColumns[0].parentColumn);
        const PivotGroupHeader = hasHeaderGroups &&
            (PivotParentColumn
                ? PivotParentColumn.Header
                : pivotColumns[0].PivotHeader || pivotColumns[0].Header);
        let pivotColumnGroup = {
            Header: PivotGroupHeader,
            columns: pivotColumns.map(col => (Object.assign(Object.assign(Object.assign({}, props.pivotDefaults), col), { pivoted: true }))),
        };
        // Place the pivotColumns back into the visibleColumns
        if (pivotIndex >= 0) {
            pivotColumnGroup = Object.assign(Object.assign({}, visibleColumns[pivotIndex]), pivotColumnGroup);
            visibleColumns.splice(pivotIndex, 1, pivotColumnGroup);
        }
        else {
            visibleColumns.unshift(pivotColumnGroup);
        }
    }
    // Build Header Groups
    const headerGroups = [];
    let currentSpan = [];
    // A convenience function to add a header and reset the currentSpan
    const addHeader = (columns, column) => {
        headerGroups.push(Object.assign(Object.assign(Object.assign({}, props.column), column), { columns }));
        currentSpan = [];
    };
    // Build flast list of allVisibleColumns and HeaderGroups
    visibleColumns.forEach(column => {
        if (column.columns) {
            allVisibleColumns = allVisibleColumns.concat(column.columns);
            if (currentSpan.length > 0) {
                addHeader(currentSpan);
            }
            addHeader(column.columns, column);
            return;
        }
        allVisibleColumns.push(column);
        currentSpan.push(column);
    });
    if (hasHeaderGroups && currentSpan.length > 0) {
        addHeader(currentSpan);
    }
    // Access the data
    const accessRow = (d, i, level = 0) => {
        const row = {
            [originalKey]: d,
            [indexKey]: i,
            [subRowsKey]: d[subRowsKey],
            [nestingLevelKey]: level,
        };
        allDecoratedColumns.forEach(column => {
            if (column.expander)
                return;
            row[column.id] = column.accessor(d);
        });
        if (row[subRowsKey]) {
            row[subRowsKey] = row[subRowsKey].map((d, i) => accessRow(d, i, level + 1));
        }
        return row;
    };
    let resolvedData = data.map((d, i) => accessRow(d, i));
    const aggregatingColumns = allVisibleColumns.filter(d => !d.expander && d.aggregate);
    // If pivoting, recursively group the data
    const aggregate = rows => {
        const aggregationValues = {};
        aggregatingColumns.forEach(column => {
            const values = rows.map(d => d[column.id]);
            aggregationValues[column.id] = column.aggregate(values, rows);
        });
        return aggregationValues;
    };
    if (pivotBy.length) {
        const groupRecursively = (rows, keys, i = 0) => {
            // This is the last level, just return the rows
            if (i === keys.length) {
                return rows;
            }
            // Group the rows together for this level
            let groupedRows = Object.entries(_.groupBy(rows, keys[i])).map(([key, value]) => ({
                [pivotIDKey]: keys[i],
                [pivotValKey]: key,
                [keys[i]]: key,
                [subRowsKey]: value,
                [nestingLevelKey]: i,
                [groupedByPivotKey]: true,
            }));
            // Recurse into the subRows
            groupedRows = groupedRows.map(rowGroup => {
                const subRows = groupRecursively(rowGroup[subRowsKey], keys, i + 1);
                return Object.assign(Object.assign(Object.assign({}, rowGroup), { [subRowsKey]: subRows, [aggregatedKey]: true }), aggregate(subRows));
            });
            return groupedRows;
        };
        resolvedData = groupRecursively(resolvedData, pivotBy);
    }
    return Object.assign(Object.assign({}, newState), { resolvedData,
        allVisibleColumns,
        headerGroups,
        allDecoratedColumns,
        hasHeaderGroups });
};
ReactTable.getSortedData = (resolvedState, props) => {
    const { manual, sorted, filtered, defaultFilterMethod, resolvedData, allVisibleColumns, allDecoratedColumns, } = resolvedState;
    const sortMethodsByColumnID = {};
    allDecoratedColumns
        .filter(col => col.sortMethod)
        .forEach(col => {
        sortMethodsByColumnID[col.id] = col.sortMethod;
    });
    // Resolve the data from either manual data or sorted data
    return {
        sortedData: manual
            ? resolvedData
            : ReactTable.sortData(ReactTable.filterData(resolvedData, filtered, defaultFilterMethod, allVisibleColumns, props), sorted, sortMethodsByColumnID, props),
    };
};
ReactTable.filterData = (data, filtered, defaultFilterMethod, allVisibleColumns, props) => {
    let filteredData = data;
    if (filtered.length) {
        filteredData = filtered.reduce((filteredSoFar, nextFilter) => {
            const column = allVisibleColumns.find(x => x.id === nextFilter.id);
            // Don't filter hidden columns or columns that have had their filters disabled
            if (!column || column.filterable === false) {
                return filteredSoFar;
            }
            const filterMethod = column.filterMethod || defaultFilterMethod;
            // If 'filterAll' is set to true, pass the entire dataset to the filter method
            if (column.filterAll) {
                return filterMethod(nextFilter, filteredSoFar, column);
            }
            return filteredSoFar.filter(row => filterMethod(nextFilter, row, column));
        }, filteredData);
        // Apply the filter to the subrows if we are pivoting, and then
        // filter any rows without subcolumns because it would be strange to show
        filteredData = filteredData
            .map(row => {
            if (!row[props.subRowsKey]) {
                return row;
            }
            return Object.assign(Object.assign({}, row), { [props.subRowsKey]: ReactTable.filterData(row[props.subRowsKey], filtered, defaultFilterMethod, allVisibleColumns, props) });
        })
            .filter(row => {
            if (!row[props.subRowsKey]) {
                return true;
            }
            return row[props.subRowsKey].length > 0;
        });
    }
    return filteredData;
};
ReactTable.sortData = (data, sorted, sortMethodsByColumnID = {}, props) => {
    if (!sorted.length) {
        return data;
    }
    const sortedData = _.orderBy(data, sorted.map(sort => {
        // Support custom sorting methods for each column
        if (sortMethodsByColumnID[sort.id]) {
            return (a, b) => sortMethodsByColumnID[sort.id](a[sort.id], b[sort.id], sort.desc);
        }
        return (a, b) => props.defaultSortMethod(a[sort.id], b[sort.id], sort.desc);
    }), sorted.map(d => !d.desc), props.indexKey);
    sortedData.forEach(row => {
        if (!row[props.subRowsKey]) {
            return;
        }
        row[props.subRowsKey] = ReactTable.sortData(row[props.subRowsKey], sorted, sortMethodsByColumnID, props);
    });
    return sortedData;
};

const StyledPagingTable = styled(ReactTable) `
  max-width: 100%;
  width: 100%;
  overflow: hidden;
`;

const responsiveColumns = (size, columns) => Array.isArray(columns)
    ? columns.map(column => {
        if (size === undefined) {
            return column;
        }
        let { show } = column;
        if (column.responsiveShow) {
            const sizes = Array.isArray(column.responsiveShow)
                ? column.responsiveShow
                : [column.responsiveShow];
            if (sizes.indexOf(size) !== -1) {
                show = true;
            }
        }
        if (column.responsiveHide) {
            const sizes = Array.isArray(column.responsiveHide)
                ? column.responsiveHide
                : [column.responsiveHide];
            if (sizes.indexOf(size) !== -1) {
                show = false;
            }
        }
        if (show === undefined) {
            return column;
        }
        return Object.assign(Object.assign({}, column), { show });
    })
    : columns;
/**
 * Table component with pagination, filtering, footer, child rows and grouping<br/>
 * Derived from https://github.com/react-tools/react-table<br/>
 * `import { PagingTable } from 'grommet-controls';`<br/>
 * `<PagingTable columns={...} data={...} />`<br/>
 */
const PagingTable = (_a) => {
    var { data, columns } = _a, rest = __rest(_a, ["data", "columns"]);
    const defaults = {
        showPagination: rest.onFetchData !== undefined ||
            (data && data.length > (rest.defaultPageSize || 20)),
        minRows: data && data.length < (rest.defaultPageSize || 20) ? 0 : undefined,
    };
    const newProps = Object.assign(Object.assign({}, defaults), rest);
    return (React.createElement(ResponsiveContext.Consumer, null, size => (React.createElement(ThemeContext.Consumer, null, theme => (React.createElement(StyledPagingTable, Object.assign({ data: data || [], columns: responsiveColumns(size, columns), theme: theme }, newProps)))))));
};
PagingTable.defaultProps = {
    defaultPageSize: 20,
    filterable: false,
    loading: false,
    manual: false,
    resizable: true,
    showPagination: true,
    sortable: true,
};

/**
 * A Select field with form validation<br/>
 */
const SelectField = (props) => (React.createElement(WithFormField, Object.assign({}, props), (_a) => {
    var { options } = _a, rest = __rest(_a, ["options"]);
    return React.createElement(Select, Object.assign({ options: options }, rest));
}));

/** Collapsible side bar component
 * ```$ npm install grommet-controls
 * import { Sidebar } from 'grommet-controls';
 * <Sidebar title='My title'>
       ...
 * </Sidebar>
 * ```
 */
const Sidebar = (_a) => {
    var { title, width, children, collapsible } = _a, rest = __rest(_a, ["title", "width", "children", "collapsible"]);
    const [collapsed, setCollapsed] = React.useState(undefined);
    const BtnToggle = ({ view }) => collapsible ? (React.createElement(Button, { icon: React.createElement(Menu, null), onClick: () => setCollapsed(view !== 'collapsed') })) : null;
    return (React.createElement(ResponsiveContext.Consumer, null, size => (collapsible && size === 'small' && collapsed === undefined) ||
        collapsed === true ? (React.createElement(Box, { align: "start" },
        React.createElement(BtnToggle, { view: "collapsed" }))) : (React.createElement(Box, Object.assign({ width: width }, rest),
        React.createElement(Box, { pad: { bottom: 'small' }, gap: "small", direction: "row", align: "center" },
            React.createElement(BtnToggle, { view: "expanded" }),
            title && (React.createElement(Box, { flex: false, tag: "header" }, typeof title === 'string' ? (React.createElement(Heading, { margin: "none", level: 3 }, title)) : (title)))),
        children))));
};
Sidebar.defaultProps = {
    title: undefined,
    width: 'medium',
    collapsible: true,
};

const disabledStyle = `
  opacity: 0.4;
  cursor: default;
`;
const StyledIcon = styled.span `
  display: inline-block;
  > * {
    vertical-align: bottom;
  }
  ${props => !props.disabled && 'cursor: pointer;'}
`;
const StyledTag = styled(Box) `
  ${props => backgroundStyle(props.background || 'brand', props.theme)}
  ${props => props.onClick && 'cursor: pointer;'}
  user-select: none;
  ${props => props.disabled && disabledStyle}
`;

/**
 * A tag control with a label and icon<br/>
 * `import { Tag } from 'grommet-controls';`<br/>
 * `<Tag label={...} icon={...} />`<br/>
 */
const Tag = React.forwardRef((_a, ref) => {
    var { disabled, label, a11yTitle, reverse, background, onClick, onChange, icon, color, focusable, round, size, truncate } = _a, rest = __rest(_a, ["disabled", "label", "a11yTitle", "reverse", "background", "onClick", "onChange", "icon", "color", "focusable", "round", "size", "truncate"]);
    const clickTag = e => {
        if (!disabled && onClick) {
            onClick(e);
        }
        e.preventDefault();
        e.stopPropagation();
    };
    const toggleTag = e => {
        if (!disabled && onChange) {
            e.preventDefault();
            e.stopPropagation();
            onChange(e);
        }
    };
    const tagRound = round;
    const canFocus = focusable && !disabled && !!(onClick || onChange);
    return (React.createElement(Keyboard, { onEnter: clickTag, onSpace: toggleTag },
        React.createElement(ThemeContext.Consumer, null, theme => {
            let closeIcon;
            if (icon || onChange) {
                closeIcon = (React.createElement(StyledIcon, { theme: theme, disabled: disabled, onClick: onChange }, icon || React.createElement(FormClose, { theme: theme })));
            }
            return (React.createElement(StyledTag, Object.assign({ ref: ref, direction: reverse ? 'row-reverse' : 'row', justify: "between", align: "center", a11yTitle: a11yTitle, round: tagRound, onClick: onClick && clickTag, role: "checkbox", "aria-checked": true, tabIndex: canFocus ? 0 : undefined, background: background, disabled: disabled, theme: theme }, rest),
                reverse && closeIcon,
                React.isValidElement(label) ? (label) : (React.createElement(Text, { color: color, size: size, truncate: truncate }, label && label.toString())),
                !reverse && closeIcon));
        })));
});
Tag.displayName = 'Tag';
Tag.defaultProps = {
    label: 'Text',
    pad: { horizontal: 'xsmall' },
    focusable: true,
};

const TagsSelect = (props) => {
    const _a = props || { tagProps: {} }, { tagProps } = _a, rest = __rest(_a, ["tagProps"]);
    return ({ placeholder, value, onChange }) => (React.createElement(Tags, Object.assign({ focusable: false, placeholder: placeholder, value: value, onChange: onChange, tagProps: Object.assign(Object.assign({}, tagProps), { onClick: e => e.stopPropagation() }) }, rest)));
};
/**
 * A list of tags that can be removed<b/>
 * `import { Tags } from 'grommet-controls';`<b/>
 * `<Tags />`<b/>
 */
class Tags extends Component {
    constructor() {
        super(...arguments);
        this.state = {
            selectedTagIndex: -1,
        };
        this.tagRefs = [];
        this.elementRef = React.createRef();
        this.selectTag = (selected) => {
            const { onChange, value } = this.props;
            if (onChange) {
                let tags = selected;
                if (Array.isArray(value)) {
                    const index = value.indexOf(tags);
                    if (index !== -1) {
                        tags = value.filter(item => item !== selected);
                    }
                    else {
                        tags = [...value, tags];
                    }
                }
                else {
                    tags = [tags];
                }
                onChange({ target: findDOMNode(this.elementRef.current), option: selected, value: tags });
            }
        };
        this.onNextTag = (event) => {
            const { value } = this.props;
            const { selectedTagIndex } = this.state;
            event.preventDefault();
            let index = selectedTagIndex + 1;
            if (index >= value.length) {
                index = 0;
            }
            this.focusTag(index);
        };
        this.onPreviousTag = (event) => {
            const { selectedTagIndex } = this.state;
            const { value } = this.props;
            event.preventDefault();
            let index = selectedTagIndex - 1;
            if (index < 0) {
                index = value.length - 1;
            }
            this.focusTag(index);
        };
        this.onSelectTag = (event) => {
            const { value } = this.props;
            const { selectedTagIndex } = this.state;
            if (selectedTagIndex >= 0 && selectedTagIndex < value.length) {
                event.preventDefault(); // prevent submitting forms
                event.stopPropagation();
                this.selectTag(value[selectedTagIndex]);
            }
        };
        this.onCloseClick = (e, tag) => {
            e.stopPropagation();
            this.selectTag(tag);
        };
    }
    focusTag(index) {
        if (index >= 0 && index < this.tagRefs.length) {
            const tagElement = findDOMNode(this.tagRefs[index].current);
            if (tagElement && typeof tagElement.focus === 'function') {
                tagElement.focus();
            }
            this.setState({ selectedTagIndex: index });
        }
    }
    render() {
        const _a = this.props, { placeholder, children, value, onChange, focusable, onClick, direction, icon, tagProps } = _a, rest = __rest(_a, ["placeholder", "children", "value", "onChange", "focusable", "onClick", "direction", "icon", "tagProps"]);
        let noValues;
        if ((!value || (Array.isArray(value) && value.length === 0))) {
            noValues = React.isValidElement(placeholder) ? placeholder : (
            // placeholder. minimum height of icon to keep size
            React.createElement(Text, { color: 'placeholder', style: { minHeight: '24px' } }, placeholder || 'No selection'));
        }
        let values;
        if (Array.isArray(value)) {
            values = value;
        }
        else {
            values = value ? [value] : [];
        }
        return (React.createElement(Keyboard, { onEnter: this.onSelectTag, onSpace: this.onSelectTag, onLeft: this.onPreviousTag, onRight: this.onNextTag },
            React.createElement(Box, Object.assign({ tabIndex: focusable ? 0 : undefined, ref: this.elementRef, direction: direction, overflow: 'auto', style: { minWidth: 'auto' } }, rest), noValues || values.map((tag, index) => {
                if (children) {
                    return children(tag, index, value);
                }
                if (!this.tagRefs[index]) {
                    this.tagRefs[index] = React.createRef();
                }
                return (React.createElement(Tag, Object.assign({ key: `tag_${tag}_${index}`, ariaChecked: true, a11yTitle: `Remove ${tag.toString()}`, label: typeof tag !== 'object' ? tag.toString() : undefined, ref: this.tagRefs[index], onClick: onClick ? e => onClick(e, tag) : undefined, onChange: onChange ? e => this.onCloseClick(e, tag) : undefined, icon: icon }, (typeof tag === 'object' ? Object.assign(Object.assign({}, tagProps), tag) : tagProps))));
            }))));
    }
}
Tags.defaultProps = {
    pad: 'small',
    focusable: true,
    margin: { horizontal: 'xsmall', vertical: 'small' },
    value: [],
    gap: 'xsmall',
    direction: 'row-responsive',
    icon: React.createElement(FormClose, null),
};

/**
 * A TextArea field with form validation<br/>
 */
const TextAreaField = (props) => (React.createElement(WithFormField, Object.assign({}, props), childProps => React.createElement(TextArea, Object.assign({}, childProps))));

/**
 * A TextInput field with form validation<br/>
 */
const TextInputField = (props) => (React.createElement(WithFormField, Object.assign({}, props), childProps => React.createElement(TextInput, Object.assign({}, childProps))));

const aqua$1 = '#00ffff';
const azure = '#f0ffff';
const beige = '#f5f5dc';
const black$1 = '#000000';
const blue$2 = '#0000ff';
const brown$1 = '#a52a2a';
const cyan$1 = '#00ffff';
const darkblue = '#00008b';
const darkcyan = '#008b8b';
const darkgrey = '#a9a9a9';
const darkgreen = '#006400';
const darkkhaki = '#bdb76b';
const darkmagenta = '#8b008b';
const darkolivegreen = '#556b2f';
const darkorange = '#ff8c00';
const darkorchid = '#9932cc';
const darkred = '#8b0000';
const darksalmon = '#e9967a';
const darkviolet = '#9400d3';
const fuchsia$1 = '#ff00ff';
const gold = '#ffd700';
const green$2 = '#008000';
const indigo$1 = '#4b0082';
const khaki = '#f0e68c';
const lightblue = '#add8e6';
const lightcyan = '#e0ffff';
const lightgreen = '#90ee90';
const lightgrey = '#d3d3d3';
const lightpink = '#ffb6c1';
const lightyellow = '#ffffe0';
const lime$2 = '#00ff00';
const magenta = '#ff00ff';
const maroon$1 = '#800000';
const navy$1 = '#000080';
const olive$1 = '#808000';
const orange$1 = '#ffa500';
const pink$1 = '#ffc0cb';
const purple$2 = '#800080';
const violet = '#800080';
const red$1 = '#ff0000';
const silver$1 = '#c0c0c0';
const white$1 = '#ffffff';
const yellow$2 = '#ffff00';
const uiColors = {
    aqua: aqua$1,
    azure,
    beige,
    black: black$1,
    blue: blue$2,
    brown: brown$1,
    cyan: cyan$1,
    darkblue,
    darkcyan,
    darkgrey,
    darkgreen,
    darkkhaki,
    darkmagenta,
    darkolivegreen,
    darkorange,
    darkorchid,
    darkred,
    darksalmon,
    darkviolet,
    fuchsia: fuchsia$1,
    gold,
    green: green$2,
    indigo: indigo$1,
    khaki,
    lightblue,
    lightcyan,
    lightgreen,
    lightgrey,
    lightpink,
    lightyellow,
    lime: lime$2,
    magenta,
    maroon: maroon$1,
    navy: navy$1,
    olive: olive$1,
    orange: orange$1,
    pink: pink$1,
    purple: purple$2,
    violet,
    red: red$1,
    silver: silver$1,
    white: white$1,
    yellow: yellow$2,
};

const isExisty = value => value !== null && value !== undefined;
const isEmpty = value => value === '';
const isDefaultRequiredValue = (_values, value) => value === undefined || value === '';
const required = (_values, value) => isExisty(value) && !isEmpty(value);
const matchRegexp = (_values, value, regexp) => !isExisty(value) || isEmpty(value) || regexp.test(value);
const notEmptyString = (_values, value) => !isEmpty(value);
const isEmail = (values, value) => matchRegexp(values, value, /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i);
const isUrl = (values, value) => matchRegexp(values, value, /^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!&',;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!&',;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!&',;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!&',;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!&',;=]|:|@)|\/|\?)*)?$/i);
const isTrue = (_values, value) => value === true;
const isFalse = (_values, value) => value === false;
const isNumeric = (values, value) => typeof value === 'number'
    ? true
    : matchRegexp(values, value, /^[-+]?(?:\d*[.])?\d+$/);
const isAlpha = (values, value) => matchRegexp(values, value, /^[A-Z]+$/i);
const isAlphanumeric = (values, value) => matchRegexp(values, value, /^[0-9A-Z]+$/i);
const isInt = (values, value) => matchRegexp(values, value, /^(?:[-+]?(?:0|[1-9]\d*))$/);
const isFloat = (values, value) => matchRegexp(values, value, /^(?:[-+]?(?:\d+))?(?:\.\d*)?(?:[eE]?(?:\d+))?$/);
const isWords = (values, value) => matchRegexp(values, value, /^[A-Z\s]+$/i);
const startsWith = str => (_values, value) => !isEmpty(value) && value.startsWith(str);
const isLength = length => (_values, value) => !isExisty(value) || isEmpty(value) || value.length === length;
const equals = eql => (_values, value) => !isExisty(value) || isEmpty(value) || value === eql;
const equalsField = field => (values, value) => value === values[field];
const maxLength = length => (_values, value) => !isExisty(value) || value.length <= length;
const minLength = length => (_values, value) => !isExisty(value) || isEmpty(value) || value.length >= length;
const isBigger = number => (_values, value) => !isExisty(value) || value > number;
const isSmaller = number => (_values, value) => !isExisty(value) || value < number;
const isBiggerOrEqual = number => (_values, value) => !isExisty(value) || value >= number;
const isSmallerOrEqual = number => (_values, value) => !isExisty(value) || value <= number;
const invalidFieldMessage = label => `${label} is not valid`;
const requiredFieldMessage = label => `${label} is required`;
const canNotBeEmptyFieldMessage = label => `${label} can not be empty`;
const ruleWrapper = (rule, customMessage, defaultMessage) => (dataRow, value, index) => {
    if (rule(dataRow, value, index)) {
        return undefined;
    }
    return customMessage || defaultMessage;
};
const validators = {
    required: (message) => ruleWrapper(required, message, requiredFieldMessage),
    email: (message) => ruleWrapper(isEmail, message, invalidFieldMessage),
    url: (message) => ruleWrapper(isUrl, message, invalidFieldMessage),
    defaultRequired: (message) => ruleWrapper(isDefaultRequiredValue, message, requiredFieldMessage),
    notEmptyString: (message) => ruleWrapper(notEmptyString, message, canNotBeEmptyFieldMessage),
    numeric: (message) => ruleWrapper(isNumeric, message, label => `${label} must be a numeric value`),
    alpha: (message) => ruleWrapper(isAlpha, message, label => `${label} must be alphabetic`),
    alphaNumeric: (message) => ruleWrapper(isAlphanumeric, message, label => `${label} must be alphanumeric`),
    int: (message) => ruleWrapper(isInt, message, label => `${label} must be an integer`),
    float: (message) => ruleWrapper(isFloat, message, label => `${label} must be a number`),
    words: (message) => ruleWrapper(isWords, message, label => `${label} must be a collection of words`),
    length: (length, message) => ruleWrapper(isLength(length), message, label => `${label} must be ${length} characters long`),
    minLength: (length, message) => ruleWrapper(minLength(length), message, label => `${label} must be at least ${length} characters long`),
    maxLength: (length, message) => ruleWrapper(maxLength(length), message, label => `${label} must be up to ${length} characters long`),
    equals: (value, message) => ruleWrapper(equals(value), message, label => `${label} must be equal to ${value}`),
    equalsField: (field, fieldLabel, message) => ruleWrapper(equalsField(field), message, label => `${label} does not match ${fieldLabel || field}`),
    True: (message) => ruleWrapper(isTrue, message, label => `${label} must be True`),
    False: (message) => ruleWrapper(isFalse, message, label => `${label} must be False`),
    bigger: (value, message) => ruleWrapper(isBigger(value), message, label => `${label} must be bigger than ${value}`),
    biggerOrEqual: (value, message) => ruleWrapper(isBiggerOrEqual(value), message, label => `${label} must be bigger or eqial to ${value}`),
    smaller: (value, message) => ruleWrapper(isSmaller(value), message, label => `${label} must be smaller than ${value}`),
    smallerOrEqual: (value, message) => ruleWrapper(isSmallerOrEqual(value), message, label => `${label} must be smaller or equal to ${value}`),
    startsWith: (value, message) => ruleWrapper(startsWith(value), message, label => `${label} must start with ${value}`),
};

const LABEL_SIZE_MAP = {
    xsmall: 'xsmall',
    small: 'xsmall',
    medium: 'xsmall',
    large: 'small',
    xlarge: 'medium',
    xxlarge: 'large',
};
/**
 * A single value visualization with a label<br/>
 * `import { Value } from 'grommet-controls';`<br/>
 * `<Value value={...} label={...} />`<br/>
 */
const Value = ({ label, value, size, weight, gap, units, color, }) => (React.createElement(Box, { gap: gap },
    React.isValidElement(value) ? (value) : (React.createElement(Text, { size: size, weight: weight, color: color }, `${value !== undefined ? value : '-'}${units ? ` ${units}` : ''}`)),
    React.createElement(Box, { alignSelf: "end" },
        React.createElement(Text, { size: LABEL_SIZE_MAP[size], color: color }, label))));
Value.defaultProps = {
    label: undefined,
    value: undefined,
    weight: 'bold',
    gap: 'small',
    size: 'large',
    color: undefined,
};

const isActive = (active, item) => item.id === active.id || item.label === active.label;
const hasActiveChidlren = (active, item) => {
    if (isActive(active, item)) {
        if (item.items && item.items.find(t => hasActiveChidlren(active, t))) {
            return true;
        }
    }
    return false;
};
const getExpandedItems = (children, active) => children.reduce((expandedItems, item) => {
    const { items, expanded, id, label } = item;
    if (expanded || (active && hasActiveChidlren(active, item))) {
        expandedItems.push(id || label);
    }
    let childrenExpandedItems = [];
    if (items) {
        childrenExpandedItems = getExpandedItems(items, active);
    }
    return expandedItems.concat(childrenExpandedItems);
}, []);
const getCollapsibleItems = (children) => children.reduce((collapsibleItems, { items, id, label }) => {
    let childrenCollapsibleItems = [];
    if (items) {
        collapsibleItems.push(id || label);
        childrenCollapsibleItems = getCollapsibleItems(items);
    }
    return collapsibleItems.concat(childrenCollapsibleItems);
}, []);
const getFlatChildrenIds = (children) => children.reduce((flatChildren, item) => {
    flatChildren.push(item.id || item.label);
    if (item.items) {
        // eslint-disable-next-line no-param-reassign
        flatChildren = flatChildren.concat(getFlatChildrenIds(item.items));
    }
    return flatChildren;
}, []);
const getChildrenById = (children, id) => {
    let items;
    children.some(item => {
        if (item.id === id || item.label === id) {
            ({ items } = item);
            return true;
        }
        if (item.items) {
            items = getChildrenById(item.items, id);
            if (items) {
                return true;
            }
        }
        return false;
    });
    return items;
};
const filterItems = (items, search) => {
    if (search && search.length) {
        const searchLC = search.toLowerCase();
        return items
            .map(item => Object.assign({}, item))
            .filter(item => {
            const { items: children, label } = item;
            if (typeof label === 'string' &&
                label.toLowerCase().indexOf(searchLC) >= 0) {
                return true;
            }
            if (children) {
                const childItems = filterItems(children, search);
                // eslint-disable-next-line no-param-reassign
                item.items = childItems;
                if (childItems.length) {
                    return true;
                }
            }
            return false;
        });
    }
    return items;
};
const compareItems = (items, nextItems) => {
    if (!items && !nextItems) {
        return true;
    }
    if ((!items && nextItems) || (items && !nextItems)) {
        return false;
    }
    if (items.length !== nextItems.length) {
        return false;
    }
    for (let i = 0; i < items.length; i += 1) {
        if (items[i].expanded !== nextItems[i].expanded ||
            items[i].href !== nextItems[i].href ||
            items[i].icon !== nextItems[i].icon ||
            items[i].label !== nextItems[i].label ||
            items[i].onClick !== nextItems[i].onClick ||
            items[i].widget !== nextItems[i].widget ||
            !compareItems(items[i].items, nextItems[i].items)) {
            return false;
        }
    }
    return true;
};
/** Hierarchical collapsible menu
 * ```$ npm install grommet-controls\n
 * import { VerticalMenu } from 'grommet-controls';\n
 * <VerticalMenu items={...} onSelect={...} />
 *```
 */
class VerticalMenu extends Component {
    constructor() {
        super(...arguments);
        this.state = { expandedItems: [] };
        this.onMenuChange = (id, expanded) => {
            const { expandedItems, filteredItems } = this.state;
            let newExpandedItems = [...expandedItems];
            if (expanded) {
                const toBeCollapsed = [
                    id,
                    ...getFlatChildrenIds(getChildrenById(filteredItems, id)),
                ];
                newExpandedItems = newExpandedItems.filter(item => toBeCollapsed.indexOf(item) < 0);
            }
            else {
                newExpandedItems.push(id);
            }
            this.setState({
                expandedItems: newExpandedItems,
            });
        };
        this.renderItem = (item, level = 1) => {
            const { activeItem, onSelect, buttonClass } = this.props;
            const { expandedItems } = this.state;
            const { items, id, label, widget, icon } = item, rest = __rest(item, ["items", "id", "label", "widget", "icon"]);
            const itemId = id || label;
            const isExpanded = expandedItems.includes(itemId);
            const ButtonClass = (items ? Button : buttonClass) || Button;
            const itemKey = `item_${itemId}_${level}`;
            let background;
            if (activeItem && activeItem.id === id) {
                background = {
                    color: 'active',
                    opacity: 'strong',
                };
            }
            const content = (React.createElement(Box, { background: background },
                React.createElement(ButtonClass, Object.assign({ onClick: !rest.route && !rest.path
                        ? () => items
                            ? this.onMenuChange(itemId, isExpanded)
                            : onSelect && onSelect(item)
                        : undefined, hoverIndicator: { color: 'active' } }, rest),
                    React.createElement(Box, { direction: "row", align: "center", pad: "small", style: {
                            marginLeft: items ? `${12 * level}px` : `${16 * level}px`,
                        } },
                        items && (isExpanded ? React.createElement(FormDown, null) : React.createElement(FormNext, null)),
                        React.createElement(Box, { direction: "row", justify: "between", fill: "horizontal", align: "center" },
                            React.createElement(Box, { direction: "row", align: "center", gap: "small" },
                                icon,
                                typeof label === 'string' ? (React.createElement(Text, null, items ? React.createElement("strong", null, label) : label)) : (label)),
                            widget)))));
            return (React.createElement(Box, { key: itemKey },
                items ? (React.createElement(Keyboard, { onDown: () => this.onMenuChange(itemId, false), onRight: () => this.onMenuChange(itemId, false), onUp: () => this.onMenuChange(itemId, true), onLeft: () => this.onMenuChange(itemId, true) }, content)) : (content),
                items &&
                    isExpanded &&
                    items.map(child => this.renderItem(child, level + 1))));
        };
    }
    static getDerivedStateFromProps(nextProps, prevState = {}) {
        const { items, expandAll, activeItem, search } = nextProps;
        const { originalExpandAll, search: stateSearch, items: stateItems = [], } = prevState;
        if (items !== stateItems || // when instance are not the same we do not need to do a full compare.
            !compareItems(items, stateItems) ||
            expandAll !== originalExpandAll ||
            search !== stateSearch) {
            const filteredItems = filterItems(items, search);
            const collapsibleItems = getCollapsibleItems(filteredItems);
            let expandedItems;
            if (expandAll || (search && search.length)) {
                expandedItems = collapsibleItems;
            }
            else {
                expandedItems = getExpandedItems(filteredItems, activeItem);
            }
            const allExpanded = typeof expandAll !== 'undefined'
                ? expandAll
                : collapsibleItems.length === expandedItems.length;
            return {
                expandedItems,
                items,
                filteredItems,
                search,
                collapsibleItems,
                allExpanded,
                expandAll,
                originalExpandAll: expandAll,
            };
        }
        return null;
    }
    render() {
        const { filteredItems } = this.state;
        return (React.createElement(React.Fragment, null, filteredItems && filteredItems.map(item => this.renderItem(item, 1))));
    }
}

export { Avatar, Card, CardActions, CardContent, CardTitle, CheckBoxField, ColorInput, ColorInputField, Colors, DateInput, DateInputField, DropInput, EmailInput, EmailInputField, Form, Header, IconButton, ImageStamp, MaskedInput, MaskedInputField, Notification, NumberInput, NumberInputField, PagingTable, PasswordInput, PasswordInputField, SelectField, Sidebar, Spinning, Tag, Tags, TagsSelect, TextAreaField, TextInputField, Value, VerticalMenu, WithFormField, basicColors, longDate, materialColors, shortDate, smallDate, uiColors, validators };
